/********************************************************************
Copyright (c) 2017, Check Point Software Technologies Ltd.
All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
********************************************************************/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using CommonUtils;
using CheckPointObjects;

namespace CiscoMigration
{
    /// <summary>
    /// Converts Cisco ASA commands repository into Check Point objects repository.
    /// Generates conversion reports for objects and policy packages.
    /// Generates Check Point Management API command line scripts for converted objects and policy packages migration.
    /// </summary>
    public class CiscoConverter
    {
        #region Helper Classes

        private class DuplicateNameInfo
        {
            public int DuplicatesCount { get; set; }
            public bool IsCPPredefinedName { get; private set; }

            public DuplicateNameInfo(bool isCPPredefinedName)
            {
                DuplicatesCount = 0;
                IsCPPredefinedName = isCPPredefinedName;
            }
        }

        private class CiscoNetwork
        {
            public int CiscoCommandId { get; private set; }
            public string IpAddress { get; private set; }
            public string NetMask { get; private set; }

            public CiscoNetwork(int ciscoCommandId, string sIp)
            {
                CiscoCommandId = ciscoCommandId;
                IpAddress = sIp;
                NetMask = "255.255.255.255";
            }

            public CiscoNetwork(int ciscoCommandId, string sIp, string sMask)
            {
                CiscoCommandId = ciscoCommandId;
                IpAddress = sIp;
                NetMask = string.IsNullOrEmpty(sMask) ? "255.255.255.255" : sMask;
            }

            public bool IsHost()
            {
                return NetworkUtils.IsValidIp(IpAddress) && (NetMask == "255.255.255.255");
            }

            public bool IsNetwork()
            {
                return NetworkUtils.IsValidIp(IpAddress) && NetworkUtils.IsValidIp(NetMask) && (NetMask != "255.255.255.255");
            }

            public string AutoGeneratedName()
            {
                if (IsHost())
                {
                    return "host_" + IpAddress;
                }

                if (IsNetwork())
                {
                    return "network_" + IpAddress + "_" + NetworkUtils.GetMaskLength(NetMask);
                }

                Console.WriteLine("Error: unrecognized network object - Ip={0}, Mask={1}", IpAddress, NetMask);
                return "_Err_in_network-line_" + CiscoCommandId;
            }

            public string AutoGeneratedNetworkName()
            {
                if (NetworkUtils.IsValidIp(IpAddress) && NetworkUtils.IsValidIp(NetMask))
                {
                    return "network_" + IpAddress + "_" + NetworkUtils.GetMaskLength(NetMask);
                }

                Console.WriteLine("Error: unrecognized network object - Ip={0}, Mask={1}", IpAddress, NetMask);
                return "_Err_in_network-line_" + CiscoCommandId;
            }

            public override bool Equals(object obj)
            {
                if (obj == null || GetType() != obj.GetType())
                {
                    return false;
                }

                var other = obj as CiscoNetwork;
                if (other == null)
                {
                    return false;
                }

                return (other.IpAddress == IpAddress && other.NetMask == NetMask);
            }

            public override int GetHashCode()
            {
                string hash = IpAddress + "," + NetMask;
                return hash.GetHashCode();
            }
        }

        private static class CheckPointServiceObjectsFactory
        {
            public static ProtocolType ProtocolStringToProtocolType(ref string sProtocol)
            {
                var protocol = ProtocolType.NA;

                switch (sProtocol)
                {
                    case "tcp":
                        protocol = ProtocolType.Tcp;
                        break;

                    case "udp":
                        protocol = ProtocolType.Udp;
                        break;

                    case "icmp":
                        protocol = ProtocolType.Icmp;
                        break;

                    case "ip":
                        protocol = ProtocolType.Ip;
                        break;

                    default:
                        string serviceName;
                        if (CiscoKnownServices.IsKnownService(sProtocol))
                        {
                            protocol = ProtocolType.KnownOtherIpProtocol;
                        }
                        else if (CiscoKnownServices.IsKnownServiceNumber(sProtocol, out serviceName))   // protocol number is used!!!
                        {
                            protocol = ProtocolType.KnownOtherIpProtocol;
                            sProtocol = serviceName;
                        }
                        else
                        {
                            Console.WriteLine("Error: Unrecognized service protocol '{0}'", sProtocol);
                        }
                        break;
                }

                return protocol;
            }

            public static string AutoGeneratedName(CheckPointObjectsRepository cpObjects, string sProtocol, string sPortOperator, string sPort, ServiceDirection where, int ciscoCommandId)
            {
                var protocol = ProtocolStringToProtocolType(ref sProtocol);
                if (protocol == ProtocolType.KnownOtherIpProtocol)
                {
                    sPort = sProtocol;
                }

                var portOperator = TcpUdpPortOperatorType.All;

                switch (sPortOperator)
                {
                    case "all":   // avoid error reporting...
                        break;

                    case "eq":
                        portOperator = TcpUdpPortOperatorType.Eq;
                        break;

                    case "gt":
                        portOperator = TcpUdpPortOperatorType.Gt;
                        break;

                    case "lt":
                        portOperator = TcpUdpPortOperatorType.Lt;
                        break;

                    default:
                        if (!string.IsNullOrEmpty(sPortOperator))
                        {
                            Console.WriteLine("Error: unsupported port operator '{0}'", sPortOperator);
                        }
                        break;
                }

                return AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);
            }

            public static string AutoGeneratedName(CheckPointObjectsRepository cpObjects, ProtocolType protocol, TcpUdpPortOperatorType portOperator, string sPort, ServiceDirection where, int ciscoCommandId)
            {
                string name = "";
                bool serviceFound = false;

                switch (protocol)
                {
                    case ProtocolType.Tcp:
                        name = "TCP_";
                        if (portOperator == TcpUdpPortOperatorType.Gt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                        }
                        if (portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                        }
                        if (portOperator == TcpUdpPortOperatorType.Eq || portOperator == TcpUdpPortOperatorType.Range)
                        {
                            name = name + sPort;
                        }
                        if (portOperator == TcpUdpPortOperatorType.All)
                        {
                            name = name + "All";
                        }
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            name = sPort;
                        }
                        break;

                    case ProtocolType.Udp:
                        name = "UDP_";
                        if (portOperator == TcpUdpPortOperatorType.Gt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                        }
                        if (portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                        }
                        if (portOperator == TcpUdpPortOperatorType.Eq || portOperator == TcpUdpPortOperatorType.Range)
                        {
                            name = name + sPort;
                        }
                        if (portOperator == TcpUdpPortOperatorType.All)
                        {
                            name = name + "All";
                        }
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            name = sPort;
                        }
                        break;

                    case ProtocolType.Icmp:
                        name = "ICMP_" + CiscoKnownServices.ConvertIcmpServiceToType(sPort);
                        name = cpObjects.GetKnownServiceName(name, out serviceFound);
                        return serviceFound ? name : "icmp-proto";

                    case ProtocolType.Ip:
                        if (portOperator == TcpUdpPortOperatorType.All)
                        {
                            name = CheckPointObject.Any;
                        }
                        else
                        {
                            Console.WriteLine("Error: unsupported port operator '{0}' for protocol IP", portOperator);
                            name = "_Err_in_service-line_" + ciscoCommandId;
                        }
                        return name;

                    case ProtocolType.KnownOtherIpProtocol:
                        name = "OTHER_" + CiscoKnownServices.ConvertServiceToPort(sPort);
                        name = cpObjects.GetKnownServiceName(name, out serviceFound);
                        return serviceFound ? name : sPort;

                    case ProtocolType.NA:
                        Console.WriteLine("Error: Unrecognized service protocol");
                        return "_Err_in_service-line_" + ciscoCommandId;
                }

                if (where == ServiceDirection.Source)
                {
                    name = name + "_SourcePort";
                }

                return cpObjects.GetKnownServiceName(name, out serviceFound);
            }

            public static CheckPointObject CreateServiceObj(CheckPointObjectsRepository cpObjects, ProtocolType protocol, TcpUdpPortOperatorType portOperator, string sPort, ServiceDirection where, int ciscoCommandId)
            {
                CheckPointObject serviceObj = null;

                switch (protocol)
                {
                    case ProtocolType.Tcp:
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            // Skip, the referenced object will be created on its own!!!
                            return null;
                        }

                        var tcp = new CheckPoint_TcpService();

                        if (portOperator == TcpUdpPortOperatorType.Eq ||
                            portOperator == TcpUdpPortOperatorType.Range ||
                            portOperator == TcpUdpPortOperatorType.All ||
                            portOperator == TcpUdpPortOperatorType.Gt ||
                            portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            string objName = AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);

                            if (portOperator == TcpUdpPortOperatorType.All)
                            {
                                sPort = "1-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Gt)
                            {
                                sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Lt)
                            {
                                sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                            }
                            if (where == ServiceDirection.Destination)
                            {
                                tcp.Port = sPort;
                            }
                            if (where == ServiceDirection.Source)
                            {
                                tcp.SourePort = sPort;
                                tcp.Port = "1-65535";
                            }
                            tcp.Name = objName;
                            serviceObj = tcp;
                        }
                        break;

                    case ProtocolType.Udp:
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            // Skip, the referenced object will be created on its own!!!
                            return null;
                        }

                        var udp = new CheckPoint_UdpService();

                        if (portOperator == TcpUdpPortOperatorType.Eq ||
                            portOperator == TcpUdpPortOperatorType.Range ||
                            portOperator == TcpUdpPortOperatorType.All ||
                            portOperator == TcpUdpPortOperatorType.Gt ||
                            portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            string objName = AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);

                            if (portOperator == TcpUdpPortOperatorType.All)
                            {
                                sPort = "1-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Gt)
                            {
                                sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Lt)
                            {
                                sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                            }
                            if (where == ServiceDirection.Destination)
                            {
                                udp.Port = sPort;
                            }
                            if (where == ServiceDirection.Source)
                            {
                                udp.SourePort = sPort;
                                udp.Port = "1-65535";
                            }
                            udp.Name = objName;
                            serviceObj = udp;
                        }
                        break;

                    case ProtocolType.Icmp:
                        // Skip, a predefined "icmp" object is used!!!
                        break;

                    case ProtocolType.Ip:
                        if (portOperator != TcpUdpPortOperatorType.All)
                        {
                            Console.WriteLine("Error: Service protocol is 'IP', but the service is not 'any'");
                        }
                        // Skip, a predefined "any" object is used!!!
                        break;

                    case ProtocolType.KnownOtherIpProtocol:
                        {
                            string objName = AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);
                            if (!string.IsNullOrEmpty(objName))
                            {
                                var other = new CheckPoint_OtherService();
                                other.Name = objName;
                                other.IpProtocol = CiscoKnownServices.ConvertServiceToPort(sPort);
                                serviceObj = other;
                            }
                        }
                        break;

                    case ProtocolType.NA:
                        Console.WriteLine("Error: Service protocol is 'NA'");
                        break;
                }

                return serviceObj;
            }

            public static bool CheckServicesPortRangesOverlapping(CheckPointObject subsetService, CheckPointObject supersetService)
            {
                int subsetTcpPortFrom, subsetTcpPortTo;
                int supersetTcpPortFrom, supersetTcpPortTo;

                if (subsetService.GetType() == typeof (CheckPoint_TcpService) && supersetService.GetType() == typeof (CheckPoint_TcpService))
                {
                    var subsetTcp = (CheckPoint_TcpService)subsetService;
                    var supersetTcp = (CheckPoint_TcpService)supersetService;

                    GetServicePortRanges(subsetTcp.Port, out subsetTcpPortFrom, out subsetTcpPortTo);
                    GetServicePortRanges(supersetTcp.Port, out supersetTcpPortFrom, out supersetTcpPortTo);
                }
                else if (subsetService.GetType() == typeof (CheckPoint_UdpService) && supersetService.GetType() == typeof (CheckPoint_UdpService))
                {
                    var subsetUdp = (CheckPoint_UdpService)subsetService;
                    var supersetUdp = (CheckPoint_UdpService)supersetService;

                    GetServicePortRanges(subsetUdp.Port, out subsetTcpPortFrom, out subsetTcpPortTo);
                    GetServicePortRanges(supersetUdp.Port, out supersetTcpPortFrom, out supersetTcpPortTo);
                }
                else
                {
                    return false;
                }

                if (subsetTcpPortFrom >= supersetTcpPortFrom && subsetTcpPortTo <= supersetTcpPortTo)
                {
                    return true;
                }

                return false;
            }

            private static void GetServicePortRanges(string servicePort, out int from, out int to)
            {
                if (servicePort.Contains("-"))
                {
                    string[] ranges = servicePort.Split('-');
                    int.TryParse(ranges[0], out from);
                    int.TryParse(ranges[1], out to);
                }
                else   // no range
                {
                    int.TryParse(servicePort, out from);
                    int.TryParse(servicePort, out to);
                }
            }
        }

        #endregion

        #region Constants

        private const string AllInternalNetwotkGroupName = "all_internal";
        private const string InvalidServiceNamePrefix = "service_";
        private const string AutoGeneratedNameWithError = "_Err_";
        private const string HtmlErrorImageTagFormat = "<img style='width:12px;height:12px;' title='{0}' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACWElEQVR4nLWSzUtUYRSHn3fu3HvnzlxnxjGHFC0nXTioLQoNXLgSM4xqTAjaJEEtCly16B+ICtq5CltEuFVatGlRiyioIAvTMkMYCZ0cTcmx+brvvW+LQsnUVp3lc37nOXA48D9r5sSZK1N9/df3ymi7NWZ7Tt2IdSRvhaJW93m7xrg7N/N0p5zYCc51nz4Samt4E6sBX3aFxWXB0teNo+2PH05sz/q2g3RvytQqgqORxkpkpI5ysoN4lQ+hMfqqN2X+U8BGoS+arE1qAQPr8jWsi0No9QlqK0gWHdm3pyDTm7Kt5oYxK6qQBXeTO5pJ1T6baJU99iJ1zt5V4DnecKi9EZnPg9/Y5O7qMnJxgQOWIpddGd5RkDnen7A7Dw9q7nfkzEe89OyWeD5NcfItwc/vqfg0NfhA2Im/BKJQHPX7v+E8e4K7MI9y5daaoAWmiaMZtNRV4wvq9/8QZPTqs0bc18n6AkozEZEoKp/fnFe5NYRuUJIutqHRWhnuumeF++H3H2QPJpdCV7vi7uQHlN8Ex8PLfIFoLQKQ0xNo+5tQJRdVcglLwXh6Yf1cbi2iLfliQ8FLPQNqPQtSgQJvdQWtuY3wyDiBgQs4716j5tOgB0AqdA9s4TcPFcoln3EseccX11GrP0ABHlAuI6wKhN8A3Y8IRVDlMkqAUpCTkoQVoMmybvoVQhe2jlZlgQfKkeiBOrzpl5RHbiPsMDx/hF3fgCooMEEgEGWBJ9SvGyy3tCoVMzeU4yJdhafAKRVx0mk8XLx4LUozcaSLKz2U67GUL9on17LiJ2VA7hlrmrnUAAAAAElFTkSuQmCC'/>";
        private const string HtmlAlertImageTagFormat = "<img style='width:14px;height:14px;vertical-align:top;' title='{0}' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAxlBMVEUAAAAuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEAAAD2nHdHAAAAQHRSTlMABwggleHkmSRl+PlqYe7tchv1xskijp6ak9fEwt376uf8A/MeHfoC0eLj2YPrEBGJEw7sGE7+VUzvUn/LzYIUAaow6gAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxIAAAsSAdLdfvwAAACbSURBVBjTbU/XEoJADFywN+y9IGJXsBes/P9XmQ3jjA/uQ7Zc7pIDFIaJH8TiiTBMptJfn8mGilw+8gUaq8haoi9XRFUNs8aeugQNHjWBFrktQYeiC/TIfQkGFDYwJDsjwNUJ44nSdAbMVS2WSiu5sqbw/I3O3Uqws/jG3j8IuUcucnLY4kk5X6JVr0G0enD7fsa/P2zv+XrjLz5CLiCq6N/XOAAAAABJRU5ErkJggg=='/>";
        private const string HtmlAlertImageTag = "<img style='vertical-align:top;' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAxlBMVEUAAAAuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEuXJEAAAD2nHdHAAAAQHRSTlMABwggleHkmSRl+PlqYe7tchv1xskijp6ak9fEwt376uf8A/MeHfoC0eLj2YPrEBGJEw7sGE7+VUzvUn/LzYIUAaow6gAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxIAAAsSAdLdfvwAAACbSURBVBjTbU/XEoJADFywN+y9IGJXsBes/P9XmQ3jjA/uQ7Zc7pIDFIaJH8TiiTBMptJfn8mGilw+8gUaq8haoi9XRFUNs8aeugQNHjWBFrktQYeiC/TIfQkGFDYwJDsjwNUJ44nSdAbMVS2WSiu5sqbw/I3O3Uqws/jG3j8IuUcucnLY4kk5X6JVr0G0enD7fsa/P2zv+XrjLz5CLiCq6N/XOAAAAABJRU5ErkJggg=='/>";
        private const string HtmlDisabledImageTag = "<img style='width:14px;height:14px;vertical-align:top;' title='Disabled' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAA7VBMVEUAAACCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoIAAAChPON7AAAATXRSTlMABwggleHkmSRl+P75amG5OQYFNqZyG/XYGWwijrvPqpPXRhM93fsVzgv8A/MXDvoC0U/Zg8MBwonukBhOx1UfHlLGTO8Qf8vq682CFPaq09YAAAABYktHRACIBR1IAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAApElEQVQY022PxxaCUAxEYy9g771gRVTsHUWxO///Oz7gcY4LZzGZuZskRJZcbvqRx+sD/IGg00NhAAIgRuweBWLxRDKVBjJmz+aAfMFMRYglNsqoVDmpoc68gabESQtt5h10SepZpA95QKRgSJyMMFaJJpgSJ03MWJxjseRkhbWZNtiqNoGyM5ftZRy040k/Q9DsUy8GLBm688z1dn88X+8P/dUXiXocfZ5dd1wAAAAASUVORK5CYII='/>";
        private const string HtmlToolLogoImageSource = "src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAgCAYAAACcuBHKAAAACXBIWXMAAAsSAAALEgHS3X78AAABkElEQVRYw+2XvXGDQBCFv/MoNx2YbEPRgZhRA+rA6sC4A7kD1IFUgdUAY9wBhJvJHeAKcMDJw2AQf5JwoBcecLx7b/exmDzPmRoP/APcSVyHRGR8IrMjMs7USjwDMZFxp7ZjDiRExp+6Jh6BDyITtN1oWnOi8HcFdJHXtXZUsQcClnnWn0RkNkBgTzUWKbBimR+rF2ZnCOwaTnVxzBoIBDUEUiABjrexIzJZyYJvK2PcKSfgo7L6yjIP+ylRbFSugW4E/qIz+fYWHUYgBbzTs6q6UlXvljmxB/xTF6jqGngH4iYidYWZ2JPM7Ya/UNUQyERkc0a1qnLrUnit7P4tShQV7NuCWtuXO6oaAy8DlHGGtWhBJLQEPOAAPPV9u6q6VtGyyv1qwvoZjyBwqCzHvWLb+l8n/2fTZqXAcoFFZX0rIkEnEqrq2BMsLtgxqYjctEWpUcAb9CkfYccJGXAQkeOoecIWZliJ8bfGnLjGoCsiO5sZX5NO2yKSAJ61YbqRX0QyEfGB7TVImPu/6J1EBT9qv6X93O05TAAAAABJRU5ErkJggg=='";
        private const string HtmlCPLogoImageSource = "src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAAUCAYAAABYm8lAAAAACXBIWXMAAAsSAAALEgHS3X78AAAHwklEQVRo3u1aaWwUZRh+tpwC7Q5Xg1KWxRhDgaYrECoe7DSgQcGw1ggKMSxREtBEy79CSLokGggkspKYEmLS5Sj+IWSbICEQZIoVoQJOQUCOyDKAIJI6WxoRsLv+6Ptt3375Zo/W/WH0TSY7813z3tes67dP6gwAfuQHKketWWFIY14AIQBLpfFGGjfpOUhXNRvLF/gAhAFE6MoWjAxzYQB2jueZRHNvQBPv659uVfsDFy786ko9Fw0GSosTPdacsAoAABWeRLYMNAC4AVwDECVEAgAWANDpMkkB/IRsvkGjdxk57hMG0SSdVU5zAaI51/OQozL4AQynewNAtaNgb8RdWLK3EO+8OwmaeyDs+EOcPduGs4fbYFkdcLsHoqxsBCyrA5bVgYa3H2YSrsaEuoq0WUCIrloSthf/LtAVXskgAQdz8AKVOVq4DLYwBEfBbmnuD9+MMaipcVa4DetNLF7yFOrqzuP8xTOZBBskoTZKQuXCDRAzZEZxzY8pGOWl8wVEaJ28JsA8QCwLhgdpn0kKly3EiMbNkpLKFizjqdOzybxXiOHB8fZK49U8lDgKdu+P/VDz2ggAwO6GK7CsDtSs7ilka/8xxOd74HYPxL0/MxIbYAJMt8bLCAMxqFzBcJ3d10vztQCWMcGp1ghm6A64RCgPaHVQxFxdfVThamU8a8mtRwivWvr1K0JalOah2IsCFRYX7nQNa+6BAICxo77H48O2YXfDFTRv2ottn57EvHkHcOfM1R6uO8v4YWbQdENyR+VEvAvABIrNfiJOJ4G10pyL3FmchKGRogjBiHOGExPKHRIVLlS9F+7Ry86N0b3fAc/6NMolhFhJe56hPR8RHyvpTOHGU7QoBdtO1ldW1mWx350uReWCjbhy7DJ27riMc+d+x6JXirFo5Uz8dHxVtoLtLXzGNJq7T40REmAuzaBxN1lqgO7Xsb02zTUpkjMh1MYchGqwKwbgKoDxxPQIw1NX4AkpjKi8isGMIiIloraUUcPRFY91J7uj8Y02nDr+S9fDoYMYrc/Gc7O2Ysqs7fB4pmLypE4sXNiJlusF+RJsNIM2QxErNWleVZrEmKXojIlutr43iUyMeZ4w4eAmJbIVtNVnSBZjigQpIyilUcIEG6o5huVvlaBmtQ+jq5dj6tzJ2LX/A3g8wwAA586/iTlzxmbzrlYFs2UIA0jmUMeNT5MdCkbmkmGL5E7kAtnu1RVXiGepafDMCzgmT6XFSdy69QceFGqoeHUiAGDl+5MAAFVVE3omUVZHtvWWiGnBDAmWwe7TQRPFLl1hsT4pvmlpGgJR1iQJsNIrkiH+ZQMmi7uqWJwXcPSfFZ4EIpFLqKt7AW5KonrE4faH+Lb5NlavbkFNTUs27xIJzFIHwYbIApty6DQZzIXKcekICclMs0YWuMlwaaX56j7y2KazxivoDmcRbnLpnmW22OD0v7Cl+SZemtaAQWNG9phrbr6dsuonipKYPS4Jv56x8xSjrLSeriATjEjp4zkyMkzrNzML9ZLyxMnibCZEkeDwNU4uNwjgB5qPKmJdLiAUrZ4lUDrLlCN9VByh5KlEzVGwJe4kNs57hBNWJ05Y93HprgsPhxThmtVBmTdw4Y4LF+64UnXv2gMDsHb2I7xR1ok0taFNzPJL9VlTL/rCNjEoLPWexVk2Uxyxxs9ifpApg8qFrvuHXLJB5YiMZyPh0JdYGyb8y7nVuuSPADfiLhy63A+HLhWg5XoBViw5iC/3zcfrVV6MGTMEG9Z38X3X5i1Ys2kxAGDFkoOp+6opndg471GqRab4CCDHQcHEvCUS/0XoEWM/PjwA+tZBMB97ErcSCcycdgvX4++hpGRolwv+5nZq7ec756Jw6H18uGw/mk9OzKVRwa3N6ENZ8T9kkxW3P3AhcrJfaqKwcACGFI6CxzMM06cOwI2LO2BZc7rbQaUxFI+M4+tjU7D/yNTUeNHgjK01jcUrHz2bUgLQCaAf29cGwGKJjihjYqwF6aXLlp55bcnHbKnmNVmnymD4mAxvTXqOKWjg9AmvZEs02rRGY++XcfVJYcnLcPZJvBkh1+opwd5kljbO/QVeDK7FqdN38dU+i8qZZ1FafA8zxnXVuKePdgt5xrgEStxJlLiTeOnpRLqsLcQ6RgGKX60swQgRch0AhtH8OvIsPzMmRhmDxJmiIa5JJUaMdYR44zwiJXBtAI6ysBCk+KWz9qXOvIzOerStUu85JGXZ49H1RUuj9Y2s1NIVuIaYgvDulMESL8EbTQprvh6CLS1OYGxREjfbXWjY8zIqWo5jUnEC659PoLQqiaJByb56B5tZl0holpGQTEkL9xABtUSkjwj0sr1RdH8cDyo8g52mPNIV+0YwpnmZ9YYY00WtbWdBg84YHWDvWobuL01mmk6T5lAGxVidHWJZu620WABoWvkgn25fYy22ICPeJI3ugPojABjT+L8rIkxTfVKvlLs/M0OpYkjuzovuT2CCWT7mMoOsXaiigYcLoRw6exbr/QoaTeq8iaZJlJVx2TRCYhnr2DyAyayumrnDpQC2A7gCoATO/2LgQtdYB8tgcY8nY2FWSkTS1Ioh5kZNhqcpWYHO6AizvVGJhrVMeFGqhePME4jS6Zqibha4CqusloQaZnW5U6PDABD6G0N6q38NHi2bAAAAAElFTkSuQmCC'";
        
        #endregion

        #region Private Members

        private CiscoParser _ciscoParser;
        private HashSet<CiscoNetwork> _ciscoNetworkObjects;
        private IEnumerable<CiscoCommand> _ciscoAllCommands;
        private IEnumerable<CiscoCommand> _ciscoObjectCommands;
        private IEnumerable<CiscoCommand> _ciscoObjectGroupCommands;
        private IEnumerable<CiscoCommand> _ciscoAclCommands;
        private IEnumerable<CiscoCommand> _ciscoAccessGroupCommands;
        private IEnumerable<CiscoCommand> _ciscoInterfaceCommands;
        private IEnumerable<CiscoCommand> _ciscoClassMapCommands;
        private IList<CiscoCommand> _ciscoSshCommands;
        private Cisco_Hostname _ciscoHostnameCommand;
        private List<Cisco_AccessList> _ciscoGlobalAclCommands = new List<Cisco_AccessList>();

        private CheckPointObjectsRepository _cpObjects = new CheckPointObjectsRepository();
        private CheckPoint_SimpleGateway _cpSimpleGateway = null;
        private List<CheckPoint_Domain> _cpDomains = new List<CheckPoint_Domain>();
        private List<CheckPoint_Host> _cpHosts = new List<CheckPoint_Host>();
        private List<CheckPoint_Network> _cpNetworks = new List<CheckPoint_Network>();
        private List<CheckPoint_Range> _cpRanges = new List<CheckPoint_Range>();
        private List<CheckPoint_NetworkGroup> _cpNetworkGroups = new List<CheckPoint_NetworkGroup>();
        private List<CheckPoint_GroupWithExclusion> _cpGroupsWithExclusion = new List<CheckPoint_GroupWithExclusion>();
        private List<CheckPoint_Zone> _cpZones = new List<CheckPoint_Zone>();
        private List<CheckPoint_TcpService> _cpTcpServices = new List<CheckPoint_TcpService>();
        private List<CheckPoint_UdpService> _cpUdpServices = new List<CheckPoint_UdpService>();
        private List<CheckPoint_OtherService> _cpOtherServices = new List<CheckPoint_OtherService>();
        private List<CheckPoint_ServiceGroup> _cpServiceGroups = new List<CheckPoint_ServiceGroup>();
        private List<CheckPoint_TimeGroup> _cpTimeGroups = new List<CheckPoint_TimeGroup>();
        private List<CheckPoint_Package> _cpPackages = new List<CheckPoint_Package>();
        private List<CheckPoint_NAT_Rule> _cpPreorderedNatRules = new List<CheckPoint_NAT_Rule>();
        private List<CheckPoint_NAT_Rule> _cpNatRules = new List<CheckPoint_NAT_Rule>();

        private List<ConversionIncident> _conversionIncidents = new List<ConversionIncident>();
        private Dictionary<int, List<ConversionIncident>> _conversionIncidentsByCiscoLineNumber = null;   // must be generated at the end of Convert() method!!!

        private Dictionary<string, DuplicateNameInfo> _duplicateNamesLookup = new Dictionary<string, DuplicateNameInfo>(StringComparer.InvariantCultureIgnoreCase);
        private List<string> _ciscoServiceInvalidNames = new List<string>();
        private List<string> _ciscoFqdnInvalidNames = new List<string>();
        private List<string> _cpUnsafeNames = new List<string>();

        private bool _isInterInterfaceTrafficAllowed = false;
        private bool _isIntraInterfaceTrafficAllowed = false;
        private bool _hasNATConversionIncident = false;
        private string _targetFolder;
        private string _policyPackageName;
        private string _policyPackageOptimizedName;

        private enum CheckPointDummyObjectType { Host, NetworkGroup, ServiceGroup, OtherService, TimeGroup };

        #endregion

        #region Properties

        public bool ConvertNat { get; set; }
        public string DomainName { get; set; }
        public string ObjectsScriptFile { get; set; }
        public string ObjectsHtmlFile { get; set; }
        public string PolicyScriptFile { get; set; }
        public string PolicyHtmlFile { get; set; }
        public string PolicyOptimizedScriptFile { get; set; }
        public string PolicyOptimizedHtmlFile { get; set; }
        public string NatHtmlFile { get; set; }
        public string CiscoHtmlFile { get; set; }
        public int ConversionIncidentCategoriesCount { get; set; }
        public int ConversionIncidentsCommandsCount { get; set; }

        private IEnumerable<CiscoCommand> CiscoAllCommands
        {
            get
            {
                return _ciscoAllCommands ?? (_ciscoAllCommands = _ciscoParser.Flatten());
            }
        }

        private IEnumerable<CiscoCommand> CiscoObjectCommands
        {
            get
            {
                return _ciscoObjectCommands ?? (_ciscoObjectCommands = _ciscoParser.Filter("object"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoObjectGroupCommands
        {
            get
            {
                return _ciscoObjectGroupCommands ?? (_ciscoObjectGroupCommands = _ciscoParser.Filter("object-group"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoAclCommands
        {
            get
            {
                return _ciscoAclCommands ?? (_ciscoAclCommands = _ciscoParser.Filter("access-list"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoAccessGroupCommands
        {
            get
            {
                return _ciscoAccessGroupCommands ?? (_ciscoAccessGroupCommands = _ciscoParser.Filter("access-group"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoInterfaceCommands
        {
            get
            {
                return _ciscoInterfaceCommands ?? (_ciscoInterfaceCommands = _ciscoParser.Filter("interface"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoClassMapCommands
        {
            get
            {
                return _ciscoClassMapCommands ?? (_ciscoClassMapCommands = _ciscoParser.Filter("class-map"));
            }
        }

        private IList<CiscoCommand> CiscoSshCommands
        {
            get
            {
                if (_ciscoSshCommands == null)
                {
                    _ciscoSshCommands = new List<CiscoCommand>();
                    var sshCommands = _ciscoParser.Filter("ssh");

                    foreach (var sshCommand in sshCommands)
                    {
                        if (sshCommand.ConversionIncidentType == ConversionIncidentType.None)
                        {
                            _ciscoSshCommands.Add(sshCommand);
                        }
                    }
                }

                return _ciscoSshCommands;
            }
        }

        private Cisco_Hostname CiscoHostnameCommand
        {
            get
            {
                return _ciscoHostnameCommand ?? (_ciscoHostnameCommand = _ciscoParser.Filter("hostname").FirstOrDefault() as Cisco_Hostname);
            }
        }

        #endregion

        #region Events

        public event Action<int, string> ConversionProgress;

        private void RaiseConversionProgress(int progress, string title)
        {
            if (ConversionProgress != null)
            {
                ConversionProgress(progress, title);
            }
        }
        
        #endregion

        #region Constructor

        public CiscoConverter(CiscoParser ciscoParser, string ciscoFileName, string targetFolder)
        {
            _ciscoParser = ciscoParser;
            _targetFolder = targetFolder;

            ciscoFileName = Regex.Replace(ciscoFileName, @"\s+", "_");

            // policy package names
            _policyPackageName = ciscoFileName + "_policy";
            _policyPackageOptimizedName = ciscoFileName + "_policy_opt";

            // script files
            ObjectsScriptFile = _targetFolder + "\\" + ciscoFileName + "_objects.sh";
            PolicyScriptFile = _targetFolder + "\\" + _policyPackageName + ".sh";
            PolicyOptimizedScriptFile = _targetFolder + "\\" + _policyPackageOptimizedName + ".sh";

            // HTML files
            CiscoHtmlFile = _targetFolder + "\\" + ciscoFileName + ".html";
            ObjectsHtmlFile = _targetFolder + "\\" + ciscoFileName + "_objects.html";
            PolicyHtmlFile = _targetFolder + "\\" + _policyPackageName + ".html";
            PolicyOptimizedHtmlFile = _targetFolder + "\\" + _policyPackageOptimizedName + ".html";
            NatHtmlFile = _targetFolder + "\\" + ciscoFileName + "_NAT.html";
        }

        #endregion

        #region Private Methods

        private void ApplyConversionIncidentOnCheckPointObject(CheckPointObject cpObject, CiscoCommand ciscoCommand)
        {
            cpObject.ConvertedCommandId = ciscoCommand.Id;

            if (ciscoCommand.ConversionIncidentType != ConversionIncidentType.None)
            {
                cpObject.ConversionIncidentType = ciscoCommand.ConversionIncidentType;

                if (!string.IsNullOrEmpty(ciscoCommand.ConversionIncidentMessage))
                {
                    string ciscoObject = string.IsNullOrEmpty(ciscoCommand.CiscoId) ? ciscoCommand.Text : ciscoCommand.CiscoId;
                    string errorDesc = ciscoCommand.Name() + " details: " + ciscoObject + ".";

                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    ciscoCommand.ConversionIncidentMessage,
                                                                    errorDesc,
                                                                    ciscoCommand.ConversionIncidentType));
                }
            }
        }

        private void CheckObjectNameValidity(CheckPointObject cpObject, CiscoCommand ciscoCommand)
        {
            string originalName = cpObject.Name;

            if (string.IsNullOrEmpty(originalName))
            {
                ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                string errorDescription = string.Format("Cisco command: {0}.", ciscoCommand.Text);
                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                "Object name cannot be empty. Please review for further possible modifications to objects before migration.",
                                                                errorDescription,
                                                                ciscoCommand.ConversionIncidentType));

                return;
            }

            if (originalName != cpObject.SafeName())
            {
                _cpUnsafeNames.Add(originalName);

                ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                string errorDescription = string.Format("Object original name: {0}. Modified name: {1}", originalName, cpObject.SafeName());
                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                "Cisco object name contains illegal character. Modifying the original name to a Check Point valid name.",
                                                                errorDescription,
                                                                ciscoCommand.ConversionIncidentType));
            }

            if (cpObject.GetType().ToString().EndsWith("_TcpService") || cpObject.GetType().ToString().EndsWith("_UdpService"))
            {
                // TCP/UDP service name must start with a letter!!!
                if (!Char.IsLetter(originalName[0]))
                {
                    _ciscoServiceInvalidNames.Add(originalName);

                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Service original name: {0}. Modified name: {1}", originalName, InvalidServiceNamePrefix + originalName);
                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    "TCP/UDP service object name must start with a letter. Modifying the original name to a Check Point valid name.",
                                                                    errorDescription,
                                                                    ciscoCommand.ConversionIncidentType));
                }
            }

            if (cpObject.GetType().ToString().EndsWith("_Domain"))
            {
                bool isFqdn = true;

                // Check for domain name and fqdn name
                var cpDomain = (CheckPoint_Domain)cpObject;
                if (originalName != cpDomain.Fqdn)
                {
                    isFqdn = false;
                    _ciscoFqdnInvalidNames.Add(originalName);

                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Domain object name: {0}. FQDN name: {1}", originalName, cpDomain.Fqdn);
                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    "Cisco Domain object name differs from FQDN name. Using FQDN name as converted Domain object name.",
                                                                    errorDescription,
                                                                    ciscoCommand.ConversionIncidentType));
                }

                // Fqdn name must start with a dot!!!
                if ((isFqdn && !originalName.StartsWith(".")) || !cpDomain.Fqdn.StartsWith("."))
                {
                    if (isFqdn)   // do not add twice...
                    {
                        _ciscoFqdnInvalidNames.Add(originalName);
                    }

                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Domain original FQDN name: {0}. Modified name: {1}", isFqdn ? originalName : cpDomain.Fqdn, "." + cpDomain.Fqdn);
                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    "Domain FQDN name must start with a dot. Modifying the original name to a Check Point valid name.",
                                                                    errorDescription,
                                                                    ciscoCommand.ConversionIncidentType));
                }
            }

            DuplicateNameInfo duplicateNameInfo;
            if (_duplicateNamesLookup.TryGetValue(originalName, out duplicateNameInfo))
            {
                ++duplicateNameInfo.DuplicatesCount;
                _duplicateNamesLookup[originalName] = duplicateNameInfo;

                string uniqueName = string.Format("{0}_{1}", originalName, duplicateNameInfo.DuplicatesCount);
                cpObject.Name = uniqueName;

                ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                string errorTitle = duplicateNameInfo.IsCPPredefinedName
                                        ? "Detected an object with a same name in Check Point's predefined service objects repository."
                                        : "Detected an object with a non unique name. Check Point names should be case insensitive.";
                errorTitle += " Please review for further possible modifications to objects before migration.";
                string errorDescription = string.Format("Original name: {0}. Using unique name: {1}.", originalName, uniqueName);

                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id, errorTitle, errorDescription, ciscoCommand.ConversionIncidentType));

                return;
            }

            _duplicateNamesLookup.Add(originalName, new DuplicateNameInfo(false));
        }

        private void EnforceObjectNameValidity()
        {
            // Fix invalid TCP/UDP service names
            foreach (var invalidName in _ciscoServiceInvalidNames)
            {
                bool found = false;
                string validName = InvalidServiceNamePrefix + invalidName;

                // Search in TCP services
                foreach (var tcpService in _cpTcpServices)
                {
                    if (invalidName == tcpService.Name)
                    {
                        tcpService.Name = validName;
                        found = true;
                        break;
                    }
                }

                // Otherwise, search in UDP services
                if (!found)
                {
                    foreach (var udpService in _cpUdpServices)
                    {
                        if (invalidName == udpService.Name)
                        {
                            udpService.Name = validName;
                            break;
                        }
                    }
                }

                // Finally, search references in service groups
                foreach (var serviceGroup in _cpServiceGroups)
                {
                    int pos = serviceGroup.Members.IndexOf(invalidName);
                    if (pos != -1)
                    {
                        serviceGroup.Members[pos] = validName;
                    }
                }
            }

            // Fix invalid domain names
            foreach (var invalidName in _ciscoFqdnInvalidNames)
            {
                string validName = "";

                foreach (var domain in _cpDomains)
                {
                    if (invalidName == domain.Name)
                    {
                        validName = "." + domain.Fqdn;
                        domain.Name = validName;
                        break;
                    }
                }

                // Finally, search references in network groups
                foreach (var networkGroup in _cpNetworkGroups)
                {
                    int pos = networkGroup.Members.IndexOf(invalidName);
                    if (pos != -1)
                    {
                        networkGroup.Members[pos] = validName;
                    }
                }
            }

            // Fix unsafe names
            foreach (var unsafeName in _cpUnsafeNames)
            {
                CheckPointObject cpObject = _cpObjects.GetObject(unsafeName);
                if (cpObject != null)
                {
                    cpObject.Name = cpObject.SafeName();

                    // Search references in service groups
                    foreach (var serviceGroup in _cpServiceGroups)
                    {
                        int pos = serviceGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            serviceGroup.Members[pos] = cpObject.Name;
                        }
                    }

                    // Search references in network groups
                    foreach (var networkGroup in _cpNetworkGroups)
                    {
                        int pos = networkGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            networkGroup.Members[pos] = cpObject.Name;
                        }
                    }
                }
            }
        }

        private void AddCheckPointObject(CheckPointObject cpObject)
        {
            if (_cpObjects.HasObject(cpObject.Name))
            {
                return;
            }

            bool found = false;

            if (cpObject.GetType().ToString().EndsWith("_Domain"))
            {
                _cpDomains.Add((CheckPoint_Domain)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_Host"))
            {
                _cpHosts.Add((CheckPoint_Host)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_Network"))
            {
                var cpNetwork = (CheckPoint_Network)cpObject;
                if (cpNetwork.Netmask == "0.0.0.0")
                {
                    var cpRange = new CheckPoint_Range();
                    cpRange.Name = cpNetwork.Name;
                    cpRange.Comments = cpNetwork.Comments;
                    cpRange.RangeFrom = "0.0.0.0";
                    cpRange.RangeTo = "255.255.255.255";
                    _cpRanges.Add(cpRange);
                }
                else
                {
                    _cpNetworks.Add(cpNetwork);
                }
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_Range"))
            {
                _cpRanges.Add((CheckPoint_Range)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_NetworkGroup"))
            {
                _cpNetworkGroups.Add((CheckPoint_NetworkGroup)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_GroupWithExclusion"))
            {
                _cpGroupsWithExclusion.Add((CheckPoint_GroupWithExclusion)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_SimpleGateway"))
            {
                _cpSimpleGateway = (CheckPoint_SimpleGateway)cpObject;
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_Zone"))
            {
                _cpZones.Add((CheckPoint_Zone)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_TcpService"))
            {
                _cpTcpServices.Add((CheckPoint_TcpService)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_UdpService"))
            {
                _cpUdpServices.Add((CheckPoint_UdpService)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_OtherService"))
            {
                _cpOtherServices.Add((CheckPoint_OtherService)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_ServiceGroup"))
            {
                _cpServiceGroups.Add((CheckPoint_ServiceGroup)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_TimeGroup"))
            {
                _cpTimeGroups.Add((CheckPoint_TimeGroup)cpObject);
                found = true;
            }

            if (cpObject.GetType().ToString().EndsWith("_Package"))
            {
                _cpPackages.Add((CheckPoint_Package)cpObject);
                found = true;
            }

            if (found)
            {
                if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                {
                    cpObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                }

                _cpObjects.AddObject(cpObject);
            }
            else
            {
                Console.WriteLine("Check Point object type " + cpObject.GetType() + " not found!!");
            }
        }

        private CheckPointObject GetCheckPointObjectOrCreateDummy(string cpObjectName, CheckPointDummyObjectType dummyObjectType, CiscoCommand ciscoCommand, string errorTitle, string errorDescription)
        {
            var cpObject = _cpObjects.GetObject(cpObjectName);
            if (cpObject != null)
            {
                return cpObject;
            }

            CheckPointObject cpDummyObject = null;

            switch (dummyObjectType)
            {
                case CheckPointDummyObjectType.Host:
                    cpDummyObject = new CheckPoint_Host { Name = "_Err_in_network-line_" + ciscoCommand.Id, IpAddress = "1.1.1.1" };
                    break;

                case CheckPointDummyObjectType.NetworkGroup:
                    cpDummyObject = new CheckPoint_NetworkGroup { Name = "_Err_in_topology-line_" + ciscoCommand.Id };
                    break;

                case CheckPointDummyObjectType.ServiceGroup:
                    cpDummyObject = new CheckPoint_ServiceGroup { Name = "_Err_in_service-line_" + ciscoCommand.Id };
                    break;

                case CheckPointDummyObjectType.TimeGroup:
                    cpDummyObject = new CheckPoint_TimeGroup { Name = "_Err_L" + ciscoCommand.Id };   // time object name is limited to 11 characters!!!
                    break;

                case CheckPointDummyObjectType.OtherService:
                    if (!string.IsNullOrEmpty(cpObjectName))
                    {
                        cpDummyObject = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                         ProtocolType.KnownOtherIpProtocol,
                                                                                         TcpUdpPortOperatorType.NA,
                                                                                         cpObjectName,
                                                                                         ServiceDirection.Destination,
                                                                                         ciscoCommand.Id);
                        if (cpDummyObject != null && cpDummyObject.GetType() == typeof(CheckPoint_OtherService))
                        {
                            cpDummyObject.ConvertedCommandId = ciscoCommand.Id;
                            AddCheckPointObject(cpDummyObject);
                            return cpDummyObject;
                        }
                    }

                    cpDummyObject = new CheckPoint_ServiceGroup { Name = "_Err_in_service-line_" + ciscoCommand.Id };
                    break;
            }

            if (cpDummyObject != null)
            {
                cpDummyObject.ConvertedCommandId = ciscoCommand.Id;
                cpDummyObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                AddCheckPointObject(cpDummyObject);

                ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                errorDescription = string.Format("{0} Using dummy object: {1}.", errorDescription, cpDummyObject.Name);
                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id, errorTitle, errorDescription, ciscoCommand.ConversionIncidentType));
            }

            return cpDummyObject;
        }

        private CheckPointObject GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember(CheckPoint_NetworkGroup networkGroup, CiscoCommand ciscoCommand, bool createDummy = true)
        {
            if (networkGroup.Members.Count == 1)
            {
                var cpObject = _cpObjects.GetObject(networkGroup.Members[0]);
                if (cpObject != null)
                {
                    return cpObject;
                }
            }

            if (createDummy)
            {
                return GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                        CheckPointDummyObjectType.Host,
                                                        ciscoCommand,
                                                        "Error creating a NAT rule, group object cannot be used as a translated object",
                                                        "Group object details: " + networkGroup.Name + ".");
            }

            return networkGroup;
        }

        private void PopulateCiscoNetworkObjects()
        {
            _ciscoNetworkObjects = new HashSet<CiscoNetwork>();

            foreach (CiscoCommand command in CiscoAllCommands)
            {
                if (command.Name() == "network-object")
                {
                    var ciscoNetwork = (Cisco_NetworkObject)command;

                    // The referenced object will be created on its own!!!
                    if (string.IsNullOrEmpty(ciscoNetwork.ReferencedObject))
                    {
                        var network = new CiscoNetwork(command.Id, ciscoNetwork.IpAddress, ciscoNetwork.Netmask);
                        _ciscoNetworkObjects.Add(network);
                    }
                }
            }

            foreach (CiscoCommand command in CiscoAclCommands)
            {
                var ciscoAcl = (Cisco_AccessList)command;
                if (ciscoAcl.IsRemark)
                {
                    continue;
                }

                CiscoNetwork source;
                CiscoNetwork dest;

                if (ciscoAcl.Source.Type == Cisco_AccessList.SourceDest.SourceDestType.Host)
                {
                    source = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.HostIp);
                    _ciscoNetworkObjects.Add(source);
                }

                if (ciscoAcl.Source.Type == Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask)
                {
                    source = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.Subnet, ciscoAcl.Source.Netmask);
                    _ciscoNetworkObjects.Add(source);
                }

                if (ciscoAcl.Destination.Type == Cisco_AccessList.SourceDest.SourceDestType.Host)
                {
                    dest = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.HostIp);
                    _ciscoNetworkObjects.Add(dest);
                }

                if (ciscoAcl.Destination.Type == Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask)
                {
                    dest = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.Subnet, ciscoAcl.Destination.Netmask);
                    _ciscoNetworkObjects.Add(dest);
                }
            }
        }

        private void CheckCiscoInterfacesTraffic()
        {
            var ciscoInterfacesTraffic = _ciscoParser.Filter("same-security-traffic");

            foreach (var ciscoCommand in ciscoInterfacesTraffic)
            {
                var ciscoInterfaceTraffic = (Cisco_SameSecurityTraffic)ciscoCommand;

                if (ciscoInterfaceTraffic.TrafficType == Cisco_SameSecurityTraffic.InterfaceTrafficType.Inter)
                {
                    _isInterInterfaceTrafficAllowed = true;
                }

                if (ciscoInterfaceTraffic.TrafficType == Cisco_SameSecurityTraffic.InterfaceTrafficType.Intra)
                {
                    _isIntraInterfaceTrafficAllowed = true;
                }
            }
        }

        private void CheckCiscoInterfacesAntiSpoofing()
        {
            var ciscoAntiSpoofingCommands = _ciscoParser.Filter("ip verify reverse-path interface");

            foreach (var ciscoCommand in ciscoAntiSpoofingCommands)
            {
                var ciscoAntiSpoofing = (Cisco_AntiSpoofing)ciscoCommand;

                if (!string.IsNullOrEmpty(ciscoAntiSpoofing.InterfaceName))
                {
                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAntiSpoofing.Id,
                                                                    "Interface Anti-Spoofing settings should be manually fixed after migration",
                                                                    "Interface name: " + ciscoAntiSpoofing.InterfaceName,
                                                                    ConversionIncidentType.Informative));
                }
            }
        }

        private void Add_Networks()
        {
            foreach (CiscoNetwork network in _ciscoNetworkObjects)
            {
                if (network.IsHost())
                {
                    var cpHost = new CheckPoint_Host();
                    cpHost.Name = network.AutoGeneratedName();
                    cpHost.IpAddress = network.IpAddress;
                    cpHost.ConvertedCommandId = network.CiscoCommandId;
                    AddCheckPointObject(cpHost);
                }
                else if (network.IsNetwork())
                {
                    var cpNetwork = new CheckPoint_Network();
                    cpNetwork.Name = network.AutoGeneratedName();
                    cpNetwork.Subnet = network.IpAddress;
                    cpNetwork.Netmask = network.NetMask;
                    cpNetwork.ConvertedCommandId = network.CiscoCommandId;
                    AddCheckPointObject(cpNetwork);
                }
            }
        }

        private void Add_Objects()
        {
            foreach (CiscoCommand command in CiscoObjectCommands)
            {
                var ciscoObject = (Cisco_Object)command;

                switch (ciscoObject.ObjectType)
                {
                    case Cisco_Object.ObjectTypes.Fqdn:
                        var cpDomain = new CheckPoint_Domain();
                        cpDomain.Name = ciscoObject.CiscoId;
                        cpDomain.Comments = ciscoObject.Description;
                        cpDomain.Fqdn = ciscoObject.Fqdn;
                        ApplyConversionIncidentOnCheckPointObject(cpDomain, ciscoObject);
                        CheckObjectNameValidity(cpDomain, ciscoObject);
                        AddCheckPointObject(cpDomain);
                        break;

                    case Cisco_Object.ObjectTypes.Host:
                        var cpHost = new CheckPoint_Host();
                        cpHost.Name = ciscoObject.CiscoId;
                        cpHost.Comments = ciscoObject.Description;
                        cpHost.IpAddress = ciscoObject.HostAddress;
                        ApplyConversionIncidentOnCheckPointObject(cpHost, ciscoObject);
                        CheckObjectNameValidity(cpHost, ciscoObject);
                        AddCheckPointObject(cpHost);
                        break;

                    case Cisco_Object.ObjectTypes.Network:
                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = ciscoObject.CiscoId;
                        cpNetwork.Comments = ciscoObject.Description;
                        cpNetwork.Subnet = ciscoObject.Network;
                        cpNetwork.Netmask = ciscoObject.Netmask;
                        ApplyConversionIncidentOnCheckPointObject(cpNetwork, ciscoObject);
                        CheckObjectNameValidity(cpNetwork, ciscoObject);
                        AddCheckPointObject(cpNetwork);
                        break;

                    case Cisco_Object.ObjectTypes.Range:
                        var cpRange = new CheckPoint_Range();
                        cpRange.Name = ciscoObject.CiscoId;
                        cpRange.Comments = ciscoObject.Description;
                        cpRange.RangeFrom = ciscoObject.RangeFrom;
                        cpRange.RangeTo = ciscoObject.RangeTo;
                        ApplyConversionIncidentOnCheckPointObject(cpRange, ciscoObject);
                        CheckObjectNameValidity(cpRange, ciscoObject);
                        AddCheckPointObject(cpRange);
                        break;

                    case Cisco_Object.ObjectTypes.TcpService:
                        var cpTcp = new CheckPoint_TcpService();
                        cpTcp.Name = ciscoObject.CiscoId;
                        cpTcp.Comments = ciscoObject.Description;
                        cpTcp.Port = ciscoObject.ServicePort;
                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoObject);
                        CheckObjectNameValidity(cpTcp, ciscoObject);
                        AddCheckPointObject(cpTcp);
                        break;

                    case Cisco_Object.ObjectTypes.UdpService:
                        var cpUdp = new CheckPoint_UdpService();
                        cpUdp.Name = ciscoObject.CiscoId;
                        cpUdp.Comments = ciscoObject.Description;
                        cpUdp.Port = ciscoObject.ServicePort;
                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoObject);
                        CheckObjectNameValidity(cpUdp, ciscoObject);
                        AddCheckPointObject(cpUdp);
                        break;

                    case Cisco_Object.ObjectTypes.KnownOtherService:
                        var cpOtherService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                              ProtocolType.KnownOtherIpProtocol,
                                                                                              TcpUdpPortOperatorType.NA,
                                                                                              ciscoObject.ServiceProtocol,
                                                                                              ServiceDirection.Destination,
                                                                                              ciscoObject.Id);
                        if (cpOtherService != null && cpOtherService.GetType() == typeof(CheckPoint_OtherService))
                        {
                            cpOtherService.Comments = ciscoObject.Description;
                            ApplyConversionIncidentOnCheckPointObject(cpOtherService, ciscoObject);
                            AddCheckPointObject(cpOtherService);
                        }
                        break;

                    case Cisco_Object.ObjectTypes.IcmpService:
                        // Predefined "icmp" object. No special handling...
                        break;
                }
            }
        }

        private void Add_NetworkGroups()
        {
            foreach (CiscoCommand command in CiscoObjectGroupCommands)
            {
                var ciscoGroup = (Cisco_GroupObject)command;

                if (ciscoGroup.GroupType == Cisco_GroupObject.Group_Type.Network)
                {
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = ciscoGroup.CiscoId;
                    cpNetworkGroup.Comments = ciscoGroup.Description;
                    ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ciscoGroup);
                    CheckObjectNameValidity(cpNetworkGroup, ciscoGroup);

                    foreach (string groupName in ciscoGroup.MembersGroupNames)
                    {
                        cpNetworkGroup.Members.Add(groupName);
                    }

                    foreach (Cisco_NetworkObject ciscoMember in ciscoGroup.MemberObjects)
                    {
                        if (!string.IsNullOrEmpty(ciscoMember.ReferencedObject))
                        {
                            cpNetworkGroup.Members.Add(ciscoMember.ReferencedObject);
                        }
                        else
                        {
                            string memberName = (new CiscoNetwork(ciscoMember.Id, ciscoMember.IpAddress, ciscoMember.Netmask)).AutoGeneratedName();
                            if (memberName.Contains(AutoGeneratedNameWithError))
                            {
                                ciscoMember.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                ciscoMember.ConversionIncidentMessage = "Unrecognized network details: " + ciscoMember.IpAddress + " " + ciscoMember.Netmask + ".";
                            }

                            ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ciscoMember);
                            cpNetworkGroup.Members.Add(memberName);
                        }
                    }

                    AddCheckPointObject(cpNetworkGroup);
                }
            }
        }

        private void Add_Interfaces_and_Routes()
        {
            // This interface is for the TOP rule for the Non-NAT rules section!!!
            var allInternal = new CheckPoint_NetworkGroup();
            allInternal.Name = AllInternalNetwotkGroupName;

            int ciscoCommandIdWithIncident = 0;

            foreach (CiscoCommand command in CiscoInterfaceCommands)
            {
                var ciscoInterface = (Cisco_Interface)command;
                if (string.IsNullOrEmpty(ciscoInterface.CiscoId) || !ciscoInterface.HasValidIpAddress())
                {
                    // must be interface with a name and IP address!!!
                    continue;
                }

                if (!ciscoInterface.LeadsToInternet)
                {
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = ciscoInterface.CiscoId + "_subnets";

                    foreach (Cisco_Interface.Subnet subnet in ciscoInterface.Topology)
                    {
                        // Note, that a subnet can be a host in Cisco, but we want to always convert to network in CP!!!
                        string networkName = (new CiscoNetwork(ciscoInterface.Id, subnet.Network, subnet.Netmask)).AutoGeneratedNetworkName();
                        if (networkName.Contains(AutoGeneratedNameWithError))
                        {
                            ciscoInterface.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                            ciscoInterface.ConversionIncidentMessage = "Unrecognized topology details: " + subnet.Network + " " + subnet.Netmask + ".";

                            ciscoCommandIdWithIncident = ciscoInterface.Id;
                        }

                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = networkName;
                        cpNetwork.Subnet = subnet.Network;
                        cpNetwork.Netmask = subnet.Netmask;
                        AddCheckPointObject(cpNetwork);

                        cpNetworkGroup.Members.Add(cpNetwork.Name);
                    }

                    ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ciscoInterface);
                    AddCheckPointObject(cpNetworkGroup);

                    allInternal.Members.Add(cpNetworkGroup.Name);
                }

                // create host object for the interface's IP address
                var cpHost = new CheckPoint_Host();
                cpHost.Name = ciscoInterface.CiscoId + "_address";
                cpHost.IpAddress = ciscoInterface.IpAddress;
                ApplyConversionIncidentOnCheckPointObject(cpHost, ciscoInterface);
                AddCheckPointObject(cpHost);
            }

            if (ciscoCommandIdWithIncident > 0)
            {
                allInternal.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                allInternal.ConvertedCommandId = ciscoCommandIdWithIncident;
            }

            AddCheckPointObject(allInternal);
        }

        private void Add_Zones()
        {
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;
                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Inbound)
                {
                    if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                    {
                        continue;
                    }
                    aclNames.Add(ciscoAccessGroup.AccessListName);

                    var cpZone = new CheckPoint_Zone();
                    cpZone.Name = CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName;
                    ApplyConversionIncidentOnCheckPointObject(cpZone, ciscoAccessGroup);
                    AddCheckPointObject(cpZone);
                }
            }

            foreach (CiscoCommand command in CiscoInterfaceCommands)
            {
                var ciscoInterface = (Cisco_Interface)command;
                if (!string.IsNullOrEmpty(ciscoInterface.CiscoId))   // must be interface with a name!!!
                {
                    var cpZone = new CheckPoint_Zone();
                    cpZone.Name = ciscoInterface.CiscoId;
                    cpZone.Comments = "Zone without access-group";
                    ApplyConversionIncidentOnCheckPointObject(cpZone, ciscoInterface);
                    AddCheckPointObject(cpZone);
                }
            }
        }

        private void Add_or_Modify_Interface_Groups()
        {
            var interfaceGroupObjects = new List<CheckPoint_NetworkGroup>();

            foreach (CiscoCommand command in CiscoInterfaceCommands)
            {
                var ciscoInterface = (Cisco_Interface)command;
                string interfaceGroupName = ciscoInterface.CiscoId + "_subnets";
                var cpObject = _cpObjects.GetObject(interfaceGroupName);
                if (cpObject != null)
                {
                    interfaceGroupObjects.Add((CheckPoint_NetworkGroup)cpObject);
                }
            }

            var excludeNetworksFromInterface = new Dictionary<string, List<CheckPoint_Network>>();

            for (int i = 0; i < interfaceGroupObjects.Count - 1; i++)
            {
                CheckPoint_NetworkGroup grp1 = interfaceGroupObjects[i];

                for (int j = i + 1; j < interfaceGroupObjects.Count; j++)
                {
                    CheckPoint_NetworkGroup grp2 = interfaceGroupObjects[j];

                    for (int k = 0; k < grp1.Members.Count; k++)
                    {
                        string network1Name = grp1.Members[k];
                        var network1 = (CheckPoint_Network)_cpObjects.GetObject(network1Name);
                        UInt32[] range1 = NetworkUtils.GetNetworkRangeInNumbers(network1.Subnet, network1.Netmask);

                        for (int m = 0; m < grp2.Members.Count; m++)
                        {
                            string network2Name = grp2.Members[m];
                            var network2 = (CheckPoint_Network)_cpObjects.GetObject(network2Name);
                            UInt32[] range2 = NetworkUtils.GetNetworkRangeInNumbers(network2.Subnet, network2.Netmask);

                            // Check networks ranges overlap
                            if (((range2[0] >= range1[0]) && (range2[0] <= range1[1])) || ((range1[0] >= range2[0]) && (range1[0] <= range2[1])))
                            {
                                if (range1[1] - range1[0] > range2[1] - range2[0])
                                {
                                    if (excludeNetworksFromInterface.ContainsKey(grp1.Name))
                                    {
                                        excludeNetworksFromInterface[grp1.Name].Add(network2);
                                    }
                                    else
                                    {
                                        excludeNetworksFromInterface.Add(grp1.Name, new List<CheckPoint_Network>() { network2 });
                                    }
                                }
                                else
                                {
                                    if (excludeNetworksFromInterface.ContainsKey(grp2.Name))
                                    {
                                        excludeNetworksFromInterface[grp2.Name].Add(network1);
                                    }
                                    else
                                    {
                                        excludeNetworksFromInterface.Add(grp2.Name, new List<CheckPoint_Network>() { network1 });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            foreach (KeyValuePair<string, List<CheckPoint_Network>> kvp in excludeNetworksFromInterface)
            {
                // First, Rename original group name
                var origGroup = (CheckPoint_NetworkGroup)_cpObjects.GetObject(kvp.Key);
                _cpObjects.RemoveObject(origGroup.Name);
                origGroup.Name = kvp.Key + "_include";
                _cpObjects.AddObject(origGroup);

                var cpExcludedGroup = new CheckPoint_NetworkGroup();
                cpExcludedGroup.Name = kvp.Key + "_exclude";
                foreach (CheckPoint_Network network in kvp.Value)
                {
                    cpExcludedGroup.Members.Add(network.Name);
                }
                AddCheckPointObject(cpExcludedGroup);

                var cpGroupWithExclusion = new CheckPoint_GroupWithExclusion();
                cpGroupWithExclusion.Name = kvp.Key;
                cpGroupWithExclusion.Include = origGroup.Name;
                cpGroupWithExclusion.Except = cpExcludedGroup.Name;
                AddCheckPointObject(cpGroupWithExclusion);
            }
        }

        private void Add_Services_and_ServiceGroups()
        {
            foreach (CiscoCommand command in CiscoObjectGroupCommands)
            {
                var ciscoGroup = (Cisco_GroupObject)command;

                if (ciscoGroup.GroupType == Cisco_GroupObject.Group_Type.Service)
                {
                    var cpServiceGroup = new CheckPoint_ServiceGroup();
                    cpServiceGroup.Name = ciscoGroup.CiscoId;
                    cpServiceGroup.Comments = ciscoGroup.Description;

                    foreach (string groupName in ciscoGroup.MembersGroupNames)
                    {
                        cpServiceGroup.Members.Add(groupName);
                    }

                    foreach (CiscoCommand ciscoMember in ciscoGroup.MemberObjects)
                    {
                        string cpName;

                        if (ciscoMember.Name() == "service-object")
                        {
                            var ciscoService = (Cisco_ServiceObject)ciscoMember;

                            // Check for the case where we are referencing a service object by its name
                            if (!string.IsNullOrEmpty(ciscoService.RefObjectName))
                            {
                                var ciscoReferencedService = _ciscoParser.GetCommandByCiscoId(ciscoService.RefObjectName);
                                if (ciscoReferencedService != null && _cpObjects.HasObject(ciscoReferencedService.CiscoId))
                                {
                                    cpServiceGroup.Members.Add(ciscoReferencedService.CiscoId);
                                }

                                continue;
                            }

                            switch (ciscoService.Protocol)
                            {
                                case "tcp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ciscoService.Protocol,
                                                                                                   ciscoService.Operator,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoService);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ciscoService.Protocol,
                                                                                                   ciscoService.Operator,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoService);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "tcp-udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Tcp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: tcp eq " + ciscoService.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoService);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);

                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Udp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: udp eq " + ciscoService.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoService);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "icmp":
                                    cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ProtocolType.Icmp,
                                                                                               TcpUdpPortOperatorType.Eq,
                                                                                               ciscoService.Port,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoService.Id);
                                    cpServiceGroup.Members.Add(cpName);

                                    if (cpName == "icmp-proto" && !string.IsNullOrEmpty(ciscoService.Port))
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentMessage = "Unrecognized ICMP service type: " + ciscoService.Port + ". Using generic icmp-proto service";
                                    }
                                    break;

                                case "ip":
                                    if (ciscoGroup.MemberObjects.Count > 1)
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentMessage = "Ignoring service group member: generic IP protocol service.";
                                    }
                                    break;

                                default:
                                    // No need to check also for CiscoKnownServices.IsKnownServiceNumber here, 
                                    // because it is already done in Cisco_ServiceObject class!!!
                                    if (CiscoKnownServices.IsKnownService(ciscoService.Protocol))
                                    {
                                        var cpOtherService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                              ProtocolType.KnownOtherIpProtocol,
                                                                                                              TcpUdpPortOperatorType.NA,
                                                                                                              ciscoService.Protocol,
                                                                                                              ServiceDirection.Destination,
                                                                                                              ciscoService.Id);
                                        if (cpOtherService != null && cpOtherService.GetType() == typeof(CheckPoint_OtherService))
                                        {
                                            ApplyConversionIncidentOnCheckPointObject(cpOtherService, ciscoService);
                                            AddCheckPointObject(cpOtherService);

                                            cpServiceGroup.Members.Add(cpOtherService.Name);
                                        }
                                    }
                                    else
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                        ciscoGroup.ConversionIncidentMessage = "Error in member service: Unrecognized service protocol (" + ciscoService.Protocol + ")";
                                    }
                                    break;
                            }
                        }

                        if (ciscoMember.Name() == "port-object")
                        {
                            var ciscoPort = (Cisco_PortObject)ciscoMember;

                            switch (ciscoGroup.ServiceProtocol)
                            {
                                case "tcp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Tcp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: " + ciscoGroup.ServiceProtocol + " eq " + ciscoPort.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoPort);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Udp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: " + ciscoGroup.ServiceProtocol + " eq " + ciscoPort.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoPort);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "tcp-udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Tcp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: tcp eq " + ciscoPort.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoPort);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);

                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Udp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: udp eq " + ciscoPort.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoPort);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;
                            }
                        }
                    }

                    ApplyConversionIncidentOnCheckPointObject(cpServiceGroup, ciscoGroup);
                    CheckObjectNameValidity(cpServiceGroup, ciscoGroup);
                    AddCheckPointObject(cpServiceGroup);
                }
            }

            foreach (CiscoCommand command in CiscoAclCommands)
            {
                var ciscoAcl = (Cisco_AccessList)command;
                if (ciscoAcl.IsRemark)
                {
                    continue;
                }

                if (ciscoAcl.SourceProperties != null)
                {
                    CheckPointObject cpSourceService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                        ciscoAcl.SourceProperties.Protocol,
                                                                                                        ciscoAcl.SourceProperties.TcpUdpPortOperator,
                                                                                                        ciscoAcl.SourceProperties.TcpUdpPortValue,
                                                                                                        ServiceDirection.Source,
                                                                                                        ciscoAcl.Id);
                    if (cpSourceService != null &&
                        (cpSourceService.GetType() == typeof(CheckPoint_TcpService) || cpSourceService.GetType() == typeof(CheckPoint_UdpService) || cpSourceService.GetType() == typeof(CheckPoint_OtherService)))
                    {
                        ApplyConversionIncidentOnCheckPointObject(cpSourceService, ciscoAcl);
                        AddCheckPointObject(cpSourceService);
                    }
                }

                if (ciscoAcl.DestinationProperties != null)
                {
                    CheckPointObject cpDestService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                      ciscoAcl.DestinationProperties.Protocol,
                                                                                                      ciscoAcl.DestinationProperties.TcpUdpPortOperator,
                                                                                                      ciscoAcl.DestinationProperties.TcpUdpPortValue,
                                                                                                      ServiceDirection.Destination,
                                                                                                      ciscoAcl.Id);
                    if (cpDestService != null &&
                        (cpDestService.GetType() == typeof(CheckPoint_TcpService) || cpDestService.GetType() == typeof(CheckPoint_UdpService) || cpDestService.GetType() == typeof(CheckPoint_OtherService)))
                    {
                        ApplyConversionIncidentOnCheckPointObject(cpDestService, ciscoAcl);
                        AddCheckPointObject(cpDestService);
                    }
                }
            }
        }

        private void Add_Package()
        {
            var cpPackage = new CheckPoint_Package();
            cpPackage.Name = _policyPackageName;

            // add parent layer
            Add_ParentLayer(cpPackage);

            // add sub-policies
            Add_Layers_And_Rules(cpPackage);

            // add sub-policies for zones without access-groups
            Add_Layers_And_Rules_For_Other_Zones(cpPackage);

            // add global rules to every sub-policy
            Add_Global_Rules(cpPackage);

            DetectCheckPointFirewallRulesAffectedByInspectPolicy(cpPackage);

            AddCheckPointObject(cpPackage);
        }

        private void Add_ParentLayer(CheckPoint_Package package)
        {
            package.ParentLayer.Name = package.NameOfAccessLayer;

            // Add rules to parent layer due to Cisco SSH OS commands for firewall control and management.
            // These rules must be the topmost rules!!!
            if (CiscoSshCommands.Count > 0 && CiscoHostnameCommand != null)
            {
                // Create a destination simple gateway object
                string gwIpAddress = "1.1.1.1";

                var ciscoInterfaceObject = _ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + "Management");
                if (ciscoInterfaceObject != null && ciscoInterfaceObject.GetType() == typeof(Cisco_Interface))
                {
                    var ciscoInterface = (Cisco_Interface)ciscoInterfaceObject;
                    if (ciscoInterface.HasValidIpAddress())
                    {
                        gwIpAddress = ciscoInterface.IpAddress;
                    }
                }

                var cpSimpleGw = new CheckPoint_SimpleGateway();
                cpSimpleGw.Name = CiscoHostnameCommand.HostName;
                cpSimpleGw.IpAddress = gwIpAddress;
                AddCheckPointObject(cpSimpleGw);

                // Create a collection of SSH hosts/networks as a source for the rules
                var sshHosts = new List<CheckPointObject>();
                foreach (CiscoCommand command in CiscoSshCommands)
                {
                    var ssh = (Cisco_SSH)command;
                    var sshHost = new CiscoNetwork(command.Id, ssh.IpAddress, ssh.Netmask);

                    if (sshHost.IsHost())
                    {
                        var cpHost = new CheckPoint_Host();
                        cpHost.Name = sshHost.AutoGeneratedName();
                        cpHost.IpAddress = sshHost.IpAddress;
                        cpHost.ConvertedCommandId = sshHost.CiscoCommandId;
                        AddCheckPointObject(cpHost);

                        sshHosts.Add(cpHost);
                    }
                    else if (sshHost.IsNetwork())
                    {
                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = sshHost.AutoGeneratedName();
                        cpNetwork.Subnet = sshHost.IpAddress;
                        cpNetwork.Netmask = sshHost.NetMask;
                        cpNetwork.ConvertedCommandId = sshHost.CiscoCommandId;
                        AddCheckPointObject(cpNetwork);

                        sshHosts.Add(cpNetwork);
                    }
                }

                // First rule: SSH access to the Firewall
                var cpRule = new CheckPoint_Rule();
                cpRule.Name = "SSH access to the Firewall";
                cpRule.Source.AddRange(sshHosts);
                cpRule.Destination.Add(cpSimpleGw);
                cpRule.Service.Add(_cpObjects.GetObject("ssh_version_2"));
                cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                cpRule.Layer = package.NameOfAccessLayer;
                cpRule.ConversionComments = "Firewall control and management";

                package.ParentLayer.Rules.Add(cpRule);

                // Second rule: SSH access to the WebUI
                cpRule = new CheckPoint_Rule();
                cpRule.Name = "Allow access to the WebUI";
                cpRule.Source.AddRange(sshHosts);
                cpRule.Destination.Add(cpSimpleGw);
                cpRule.Service.Add(_cpObjects.GetObject("https"));
                cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                cpRule.Enabled = false;   // !!!
                cpRule.Layer = package.NameOfAccessLayer;
                cpRule.ConversionComments = "Firewall control and management";

                package.ParentLayer.Rules.Add(cpRule);

                // Third rule: Stealth Rule
                cpRule = new CheckPoint_Rule();
                cpRule.Name = "Stealth Rule";
                cpRule.Destination.Add(cpSimpleGw);
                cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                cpRule.Layer = package.NameOfAccessLayer;
                cpRule.ConversionComments = "Firewall control and management";

                package.ParentLayer.Rules.Add(cpRule);
            }

            // Add parent rules for interfaces used in access-groups
            var accessGroups = new List<string>();
            var accessGroupsExclude = new List<string>();
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;
                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Inbound)
                {
                    if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                    {
                        continue;
                    }
                    aclNames.Add(ciscoAccessGroup.AccessListName);

                    accessGroups.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);

                    // get Cisco interface object
                    var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                    if (ciscoInterface == null || !ciscoInterface.HasValidIpAddress())
                    {
                        continue;
                    }

                    // This cpObject is supposed to be a CheckPoint_Zone object, unless there was an error...
                    var cpObject = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName,
                                                                    CheckPointDummyObjectType.NetworkGroup,
                                                                    ciscoAccessGroup,
                                                                    "Error creating a parent layer rule, missing topology information for Cisco interface",
                                                                    "Interface details: " + ciscoAccessGroup.InterfaceName + ".");

                    var cpRule = new CheckPoint_Rule();
                    cpRule.Source.Add(cpObject);
                    cpRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                    cpRule.SubPolicyName = ciscoAccessGroup.AccessListName;
                    cpRule.Layer = package.NameOfAccessLayer;
                    ApplyConversionIncidentOnCheckPointObject(cpRule, ciscoAccessGroup);

                    package.ParentLayer.Rules.Add(cpRule);
                }
                else
                {
                    // No Outbound nor Global...
                    accessGroupsExclude.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                }
            }

            // Add parent rules for interfaces without access-groups
            var availableZones = new List<CheckPoint_Zone>();
            int availableZonesWithZeroSecurityLevel = 0;

            foreach (CheckPoint_Zone cpZone in _cpZones)
            {
                if (accessGroups.Contains(cpZone.Name) || accessGroupsExclude.Contains(cpZone.Name))
                {
                    continue;
                }

                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);
                if (ciscoInterface == null || !ciscoInterface.HasValidIpAddress() || ciscoInterface.ManagementOnly)
                {
                    continue;
                }

                availableZones.Add(cpZone);

                // If the _isInterInterfaceTrafficAllowed flag is on and there are at least two Cisco interfaces with zero security level, 
                // we should add parent rules for the equivalent CP zones to allow traffic between them.
                if (ciscoInterface.SecurityLevel == 0)
                {
                    ++availableZonesWithZeroSecurityLevel;
                }
            }

            foreach (CheckPoint_Zone cpZone in availableZones)
            {
                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);

                bool addParentRule = (_isIntraInterfaceTrafficAllowed || (_isInterInterfaceTrafficAllowed && availableZonesWithZeroSecurityLevel >= 2))
                                         ? (ciscoInterface.SecurityLevel >= 0)
                                         : (ciscoInterface.SecurityLevel > 0);

                if (addParentRule)
                {
                    var cpRule = new CheckPoint_Rule();
                    cpRule.Source.Add(cpZone);
                    cpRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                    cpRule.SubPolicyName = cpZone.Name + "_sub_policy";
                    cpRule.Layer = package.NameOfAccessLayer;
                    cpRule.ConversionComments = "Cisco zone with security-level " + ciscoInterface.SecurityLevel;
                    ApplyConversionIncidentOnCheckPointObject(cpRule, ciscoInterface);

                    package.ParentLayer.Rules.Add(cpRule);
                }
            }

            // Add cleanup rule
            var cpCleanupRule = new CheckPoint_Rule();
            cpCleanupRule.Name = "Cleanup rule";
            cpCleanupRule.Action = CheckPoint_Rule.ActionType.Drop;
            cpCleanupRule.Layer = package.NameOfAccessLayer;

            package.ParentLayer.Rules.Add(cpCleanupRule);
        }

        private void Add_Layers_And_Rules(CheckPoint_Package package)
        {
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;

                if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                {
                    continue;
                }

                if (ciscoAccessGroup.Direction != Cisco_AccessGroup.DirectionType.Inbound && ciscoAccessGroup.Direction != Cisco_AccessGroup.DirectionType.Global)
                {
                    ciscoAccessGroup.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAccessGroup.Id,
                                                                    "Not converting outbound ACL groups",
                                                                    "All related ACLs are skipped.",
                                                                    ciscoAccessGroup.ConversionIncidentType));

                    continue;
                }

                aclNames.Add(ciscoAccessGroup.AccessListName);

                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Global)
                {
                    foreach (CiscoCommand aclCommand in CiscoAclCommands)
                    {
                        var ciscoAcl = (Cisco_AccessList)aclCommand;
                        if (!ciscoAcl.IsRemark && ciscoAcl.ACLName == ciscoAccessGroup.AccessListName)
                        {
                            _ciscoGlobalAclCommands.Add(ciscoAcl);
                        }
                    }
                }
                else   // Inbound
                {
                    // get Cisco interface object
                    var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                    if (ciscoInterface == null)
                    {
                        ciscoAccessGroup.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAccessGroup.Id,
                                                                        "Cannot find interface assigned to ACL group",
                                                                        "Interface details: " + ciscoAccessGroup.InterfaceName + ".",
                                                                        ciscoAccessGroup.ConversionIncidentType));

                        continue;
                    }
                    if (!ciscoInterface.HasValidIpAddress())
                    {
                        ciscoAccessGroup.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAccessGroup.Id,
                                                                        "Not processing ACL groups that reference an interface without IP address",
                                                                        "All ACLs related to interface " + ciscoAccessGroup.InterfaceName + " are skipped.",
                                                                        ciscoAccessGroup.ConversionIncidentType));

                        continue;
                    }

                    var cpLayer = new CheckPoint_Layer();
                    cpLayer.Name = ciscoAccessGroup.AccessListName;
                    cpLayer.Comments = ciscoAccessGroup.Description;
                    cpLayer.IsAssociatedInterfaceDisabled = ciscoInterface.Shutdown;

                    // Automatic rule is added for management-only interface:
                    if (ciscoInterface.ManagementOnly && CiscoHostnameCommand != null)
                    {
                        var cpRule = new CheckPoint_Rule();
                        cpRule.Enabled = true;
                        cpRule.Layer = ciscoAccessGroup.AccessListName;
                        cpRule.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                        cpRule.Destination.Add(_cpObjects.GetObject(CiscoHostnameCommand.HostName));
                        cpRule.DestinationNegated = true;
                        cpRule.Service.Add(_cpObjects.GetObject(CheckPointObject.Any));
                        cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                        cpRule.ConversionComments = "Automatic rule for management-only interface";

                        cpLayer.Rules.Add(cpRule);
                    }

                    foreach (CiscoCommand aclCommand in CiscoAclCommands)
                    {
                        var ciscoAcl = (Cisco_AccessList)aclCommand;
                        if (!ciscoAcl.IsRemark && ciscoAcl.ACLName == ciscoAccessGroup.AccessListName)
                        {
                            var cpRule = Acl_To_CPRule(ciscoAcl);

                            if (ciscoInterface.Shutdown)
                            {
                                cpRule.Enabled = false;
                            }

                            cpLayer.Rules.Add(cpRule);

                            if (cpRule.ConversionIncidentType != ConversionIncidentType.None || ciscoAcl.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                package.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                    }

                    // Do NOT create a cleanup rule if it already exists
                    bool createCleanupRule = true;
                    if (cpLayer.Rules.Count > 0)
                    {
                        var lastRule = cpLayer.Rules[cpLayer.Rules.Count - 1];
                        createCleanupRule = !lastRule.IsCleanupRule();
                    }

                    if (createCleanupRule)
                    {
                        var cpCleanupRule = new CheckPoint_Rule();
                        cpCleanupRule.Name = CheckPoint_Rule.SubPolicyCleanupRuleName;
                        cpCleanupRule.Layer = cpLayer.Name;

                        cpLayer.Rules.Add(cpCleanupRule);
                    }

                    package.SubPolicies.Add(cpLayer);
                }
            }
        }

        private void Add_Global_Rules(CheckPoint_Package package)
        {
            foreach (Cisco_AccessList ciscoAcl in _ciscoGlobalAclCommands)
            {
                foreach (CheckPoint_Rule cpParentRule in package.ParentLayer.Rules)
                {
                    if (cpParentRule.Action == CheckPoint_Rule.ActionType.SubPolicy)
                    {
                        // Get into the relevant sub-policy
                        foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                        {
                            if (subPolicy.Name == cpParentRule.SubPolicyName)
                            {
                                // This is done to avoid duplication of incident reporting over all matched sub-policy rules.
                                ConversionIncidentType aclConversionIncident = ciscoAcl.ConversionIncidentType;
                                ciscoAcl.ConversionIncidentType = ConversionIncidentType.None;

                                var cpRule = Acl_To_CPRule(ciscoAcl);
                                cpRule.Layer = subPolicy.Name;

                                if (subPolicy.IsAssociatedInterfaceDisabled)
                                {
                                    cpRule.Enabled = false;
                                }

                                // If the global ACL didn't have an incident previously, 
                                // and the incident was just encountered during this convertion, retain the incident!!!
                                if (ciscoAcl.ConversionIncidentType == ConversionIncidentType.None)
                                {
                                    ciscoAcl.ConversionIncidentType = aclConversionIncident;
                                }

                                // Insert the global rules at the end of each sub-policy, BEFORE the cleanup rule.
                                int rulesCount = subPolicy.Rules.Count;
                                subPolicy.Rules.Insert(rulesCount - 1, cpRule);

                                if (cpRule.ConversionIncidentType != ConversionIncidentType.None || ciscoAcl.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    package.ConversionIncidentType = ConversionIncidentType.Informative;
                                }
                            }
                        }
                    }
                }
            }
        }

        private CheckPoint_Rule Acl_To_CPRule(Cisco_AccessList ciscoAcl)
        {
            var cpRule = new CheckPoint_Rule();
            cpRule.Name = ciscoAcl.Description;
            cpRule.Enabled = !ciscoAcl.Inactive;
            cpRule.Layer = ciscoAcl.ACLName;
            cpRule.Comments = ciscoAcl.Remark;
            cpRule.ConversionComments = ciscoAcl.Id + ") " + ciscoAcl.Text;

            ApplyConversionIncidentOnCheckPointObject(cpRule, ciscoAcl);

            CheckPointObject cpObject;
            string srcObjectName;
            string destObjectName;

            if (ciscoAcl.IsTimeRangeSpecified)
            {
                cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                            CheckPointDummyObjectType.TimeGroup,
                                                            ciscoAcl,
                                                            "Not applying time-range objects to ACLs",
                                                            "Appropriate time object should be added manually.");
                cpRule.Time.Add(cpObject);
            }

            switch (ciscoAcl.Source.Type)
            {
                case Cisco_AccessList.SourceDest.SourceDestType.Any:
                    cpRule.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Any6:
                    cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, IPv6 objects are not supported",
                                                                "Source details: Any6.");
                    cpRule.Source.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Host:
                    srcObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.HostIp)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(srcObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for source Cisco host",
                                                                "Host details: " + ciscoAcl.Source.HostIp + ".");
                    cpRule.Source.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask:
                    srcObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.Subnet, ciscoAcl.Source.Netmask)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(srcObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for source Cisco network",
                                                                "Network details: " + ciscoAcl.Source.Subnet + " " + ciscoAcl.Source.Netmask + ".");
                    cpRule.Source.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.ReferenceObject:
                    srcObjectName = ciscoAcl.Source.RefObjectName;
                    cpObject = GetCheckPointObjectOrCreateDummy(srcObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for source Cisco object",
                                                                "Object details: " + srcObjectName + ".");
                    cpRule.Source.Add(cpObject);
                    break;
            }

            switch (ciscoAcl.Destination.Type)
            {
                case Cisco_AccessList.SourceDest.SourceDestType.Any:
                    cpRule.Destination.Add(_cpObjects.GetObject(CheckPointObject.Any));
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Any6:
                    cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, IPv6 objects are not supported",
                                                                "Destination details: Any6.");
                    cpRule.Destination.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Host:
                    destObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.HostIp)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(destObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for destination Cisco host",
                                                                "Host details: " + ciscoAcl.Destination.HostIp + ".");
                    cpRule.Destination.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask:
                    destObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.Subnet, ciscoAcl.Destination.Netmask)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(destObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for destination Cisco network",
                                                                "Network details: " + ciscoAcl.Destination.Subnet + " " + ciscoAcl.Destination.Netmask + ".");
                    cpRule.Destination.Add(cpObject);
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.ReferenceObject:
                    destObjectName = ciscoAcl.Destination.RefObjectName;
                    cpObject = GetCheckPointObjectOrCreateDummy(destObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for destination Cisco object",
                                                                "Object details: " + destObjectName + ".");
                    cpRule.Destination.Add(cpObject);
                    break;
            }

            switch (ciscoAcl.Action)
            {
                case Cisco_AccessList.ActionType.Permit:
                    cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                    break;

                case Cisco_AccessList.ActionType.Deny:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
            }

            if (ciscoAcl.Protocol == ProtocolType.NA)
            {
                cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                            CheckPointDummyObjectType.ServiceGroup,
                                                            ciscoAcl,
                                                            "Error creating a rule, unrecognized Cisco ACL protocol",
                                                            "Protocol details: " + ciscoAcl.ProtocolReference + ".");
                cpRule.Service.Add(cpObject);
                return cpRule;
            }

            if (ciscoAcl.Protocol != ProtocolType.ReferenceObject)   // a specific ACL protocol is used
            {
                // Destination service should be checked first
                if (ciscoAcl.DestinationProperties.Protocol != ProtocolType.NA && (ciscoAcl.DestinationProperties.WordsCount > 0 || ciscoAcl.DestinationProperties.TcpUdpPortOperator == TcpUdpPortOperatorType.All))
                {
                    if (ciscoAcl.DestinationProperties.TcpUdpPortOperator != TcpUdpPortOperatorType.ReferenceObject)   // specific protocol with a specific port
                    {
                        string serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ciscoAcl.DestinationProperties.Protocol,
                                                                                               ciscoAcl.DestinationProperties.TcpUdpPortOperator,
                                                                                               ciscoAcl.DestinationProperties.TcpUdpPortValue,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoAcl.Id);
                        var dummyObjectType = (ciscoAcl.DestinationProperties.Protocol == ProtocolType.KnownOtherIpProtocol) ? CheckPointDummyObjectType.OtherService : CheckPointDummyObjectType.ServiceGroup;

                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    dummyObjectType,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoAcl.DestinationProperties.Protocol + " " + ciscoAcl.DestinationProperties.TcpUdpPortOperator + " " + ciscoAcl.DestinationProperties.TcpUdpPortValue + ".");
                        cpRule.Service.Add(cpObject);
                    }
                    else   // specific protocol with a service group of ports or icmp protocol with service group of icmp types
                    {
                        CiscoCommand ciscoPortReferenceCommand = _ciscoParser.GetCommandByCiscoId(ciscoAcl.DestinationProperties.TcpUdpPortValue);

                        if (ciscoPortReferenceCommand.Name() == "object-group")
                        {
                            var ciscoGroupReferenceObject = (Cisco_GroupObject)ciscoPortReferenceCommand;

                            if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Service)
                            {
                                Add_AclPorts_To_CPRule(ciscoAcl, ciscoGroupReferenceObject.ServiceProtocol, ciscoGroupReferenceObject, cpRule);
                            }
                            else if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Icmp)
                            {
                                Add_AclIcmpTypes_To_CPRule(ciscoAcl, ciscoGroupReferenceObject, cpRule);
                            }
                        }
                    }
                }

                // Now check the source service
                if (ciscoAcl.SourceProperties.Protocol != ProtocolType.NA && ciscoAcl.SourceProperties.WordsCount > 0)
                {
                    string serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                           ciscoAcl.SourceProperties.Protocol,
                                                                                           ciscoAcl.SourceProperties.TcpUdpPortOperator,
                                                                                           ciscoAcl.SourceProperties.TcpUdpPortValue,
                                                                                           ServiceDirection.Source,
                                                                                           ciscoAcl.Id);

                    // Do we already have the destination services applied?
                    if (cpRule.Service.Count > 0)
                    {
                        cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                        ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                        "Cannot convert ACL with both source service and destination service",
                                                                        "Ignoring source service: " + serviceName,
                                                                        ciscoAcl.ConversionIncidentType));
                    }
                    else   // no "regular" services - only source service
                    {
                        string errDescription;
                        if (ciscoAcl.SourceProperties.TcpUdpPortOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            errDescription = "Object details: " + ciscoAcl.SourceProperties.TcpUdpPortValue + ".";
                        }
                        else
                        {
                            errDescription = "Service details: " + ciscoAcl.SourceProperties.Protocol + " " + ciscoAcl.SourceProperties.TcpUdpPortOperator + " " + ciscoAcl.SourceProperties.TcpUdpPortValue + ".";
                        }

                        cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Cannot convert ACL with only source service",
                                                                    errDescription);
                        cpRule.Service.Add(cpObject);
                    }
                }
            }
            else   // ProtocolType.ReferenceObject - ACL protocol is a referenced "object-group" or "object"
            {
                CiscoCommand ciscoProtocolReferenceCommand = _ciscoParser.GetCommandByCiscoId(ciscoAcl.ProtocolReference);

                if (ciscoProtocolReferenceCommand.Name() == "object-group")   // services group or protocols group
                {
                    var ciscoGroupReferenceObject = (Cisco_GroupObject)ciscoProtocolReferenceCommand;

                    if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Service)
                    {
                        Add_AclServices_To_CPRule(ciscoAcl, ciscoGroupReferenceObject, cpRule);
                    }
                    else if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Protocol)
                    {
                        Add_AclProtocols_To_CPRule(ciscoAcl, ciscoGroupReferenceObject, cpRule);
                    }
                }
                else if (ciscoProtocolReferenceCommand.Name() == "object")   // service object
                {
                    var ciscoReferenceObject = (Cisco_Object)ciscoProtocolReferenceCommand;

                    if (ciscoReferenceObject.ObjectType == Cisco_Object.ObjectTypes.IcmpService)   // using a predefined icmp object
                    {
                        string icmpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                            ProtocolType.Icmp,
                                                                                            TcpUdpPortOperatorType.Eq,
                                                                                            ciscoReferenceObject.ServicePort,
                                                                                            ServiceDirection.Destination,
                                                                                            ciscoAcl.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(icmpName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: icmp " + ciscoReferenceObject.ServicePort + ".");
                        cpRule.Service.Add(cpObject);
                    }
                    else if (_cpObjects.HasObject(ciscoReferenceObject.CiscoId))
                    {
                        if (ciscoReferenceObject.IsDestination)
                        {
                            cpObject = GetCheckPointObjectOrCreateDummy(ciscoReferenceObject.CiscoId,
                                                                        CheckPointDummyObjectType.ServiceGroup,
                                                                        ciscoAcl,
                                                                        "Error creating a rule, missing information for Cisco service object",
                                                                        "Object details: " + ciscoReferenceObject.CiscoId + ".");
                            cpRule.Service.Add(cpObject);

                            // This may happen if both source and destination protocols are defined on the Cisco service!!!
                            if (ciscoReferenceObject.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                        else
                        {
                            cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                            ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                            _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                            "ACL protocol points to a source service",
                                                                            "Ignoring source service: " + ciscoReferenceObject.CiscoId + ".",
                                                                            ciscoAcl.ConversionIncidentType));
                        }
                    }
                    else
                    {
                        cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + ciscoReferenceObject.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                    }
                }
                else
                {
                    cpRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                    "Error creating a rule, missing information for Cisco ACL protocol",
                                                                    "ACL Protocol details: " + ciscoProtocolReferenceCommand.CiscoId + ".",
                                                                    ciscoAcl.ConversionIncidentType));
                }
            }

            if (ciscoAcl.Protocol == ProtocolType.Icmp && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("icmp-proto"));
            }

            if (ciscoAcl.Protocol == ProtocolType.Tcp && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("unknown_protocol_tcp"));
            }

            if (ciscoAcl.Protocol == ProtocolType.Udp && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("unknown_protocol_udp"));
            }

            if (cpRule.Service.Count == 0)
            {
                // No service detected, or generic IP service protocol was skipped.
                // "any" service object will be used automatically...
            }

            return cpRule;
        }

        private void Add_AclServices_To_CPRule(Cisco_AccessList ciscoAcl, Cisco_GroupObject aclServices, CheckPoint_Rule cpRule)
        {
            // Avoid general "icmp-proto" service duplicates
            bool hasGeneralIcmpServiceMember = false;

            foreach (Cisco_ServiceObject ciscoService in aclServices.GetChildServices())
            {
                CheckPointObject cpObject;

                // Check for the case where we are referencing a service object by its name
                if (!string.IsNullOrEmpty(ciscoService.RefObjectName))
                {
                    var ciscoReferencedService = (Cisco_Object)_ciscoParser.GetCommandByCiscoId(ciscoService.RefObjectName);
                    if (ciscoReferencedService != null && _cpObjects.HasObject(ciscoReferencedService.CiscoId))
                    {
                        if (ciscoReferencedService.IsDestination)
                        {
                            cpObject = GetCheckPointObjectOrCreateDummy(ciscoReferencedService.CiscoId,
                                                                        CheckPointDummyObjectType.ServiceGroup,
                                                                        ciscoAcl,
                                                                        "Error creating a rule, missing information for Cisco service object",
                                                                        "Object details: " + ciscoReferencedService.CiscoId + ".");
                            cpRule.Service.Add(cpObject);

                            // This may happen, for example, if: 
                            // 1. both source and destination protocols are defined on the Cisco service
                            // 2. the Cisco service has a duplicate name
                            if (ciscoReferencedService.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                        else
                        {
                            cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                            ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                            _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                            "ACL protocol points to a service group with \"source-services\"",
                                                                            "Ignoring source service: " + ciscoReferencedService.CiscoId + ".",
                                                                            ciscoAcl.ConversionIncidentType));
                        }
                    }

                    continue;
                }

                if (ciscoService.IsDestination)
                {
                    if (ciscoService.Protocol == "tcp-udp")
                    {
                        string tcpServiceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                  "tcp",
                                                                                                  ciscoService.Operator,
                                                                                                  ciscoService.Port,
                                                                                                  ServiceDirection.Destination,
                                                                                                  ciscoService.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(tcpServiceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".");
                        cpRule.Service.Add(cpObject);

                        string udpServiceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                  "udp",
                                                                                                  ciscoService.Operator,
                                                                                                  ciscoService.Port,
                                                                                                  ServiceDirection.Destination,
                                                                                                  ciscoService.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(udpServiceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".");
                        cpRule.Service.Add(cpObject);
                    }
                    else if (ciscoService.Protocol == "ip")
                    {
                        cpRule.Service.Clear();   // "any" service object will be used automatically...

                        cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                        ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                        "ACL protocol points to a service group with generic IP protocol",
                                                                        "Using \"any\" service object. Service group details: " + aclServices.CiscoId + ".",
                                                                        ciscoAcl.ConversionIncidentType));

                        return;
                    }
                    else   // regular icmp, tcp or udp, or other known ip protocol...
                    {
                        string serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ciscoService.Protocol,
                                                                                               ciscoService.Operator,
                                                                                               ciscoService.Port,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoService.Id);
                        if (serviceName == "icmp-proto")
                        {
                            if (hasGeneralIcmpServiceMember)
                            {
                                continue;
                            }
                            hasGeneralIcmpServiceMember = true;
                        }

                        var dummyObjectType = (ciscoAcl.DestinationProperties.Protocol == ProtocolType.KnownOtherIpProtocol) 
                            ? CheckPointDummyObjectType.OtherService
                            : CheckPointDummyObjectType.ServiceGroup;

                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    dummyObjectType,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".");
                        cpRule.Service.Add(cpObject);
                    }

                    // This may happen if both source and destination protocols are defined on the Cisco service!!!
                    if (ciscoService.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;
                    }
                }
                else   // reference objects with source ports
                {
                    cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                    "ACL protocol points to a service group with \"source-services\"",
                                                                    "Ignoring source service: " + ciscoService.Protocol + " " + ciscoService.Port + ", in group: " + ciscoAcl.ProtocolReference + ".",
                                                                    ciscoAcl.ConversionIncidentType));
                }
            }
        }

        private void Add_AclIcmpTypes_To_CPRule(Cisco_AccessList ciscoAcl, Cisco_GroupObject aclIcmpTypes, CheckPoint_Rule cpRule)
        {
            foreach (var icmpType in aclIcmpTypes.IcmpTypes)
            {
                string icmpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                    ProtocolType.Icmp,
                                                                                    TcpUdpPortOperatorType.Eq,
                                                                                    icmpType,
                                                                                    ServiceDirection.Destination,
                                                                                    ciscoAcl.Id);
                var cpObject = GetCheckPointObjectOrCreateDummy(icmpName,
                                                                CheckPointDummyObjectType.ServiceGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for Cisco destination service",
                                                                "Service details: icmp " + icmpType + ".");
                cpRule.Service.Add(cpObject);
            }
        }

        private void Add_AclProtocols_To_CPRule(Cisco_AccessList ciscoAcl, Cisco_GroupObject aclProtocols, CheckPoint_Rule cpRule)
        {
            foreach (var proto in aclProtocols.Protocols)
            {
                string protocol = proto;
                var protocolType = CheckPointServiceObjectsFactory.ProtocolStringToProtocolType(ref protocol);
                if (protocolType == ProtocolType.NA)
                {
                    cpRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                    "Error creating a rule, missing information for Cisco ACL protocol",
                                                                    "ACL Protocol details: " + protocol + ", in group: " + aclProtocols.CiscoId + ".",
                                                                    ciscoAcl.ConversionIncidentType));

                    continue;
                }

                string sPort = (protocolType == ProtocolType.KnownOtherIpProtocol) ? protocol : ciscoAcl.DestinationProperties.TcpUdpPortValue;

                if (protocolType == ProtocolType.KnownOtherIpProtocol || ciscoAcl.DestinationProperties.TcpUdpPortOperator != TcpUdpPortOperatorType.ReferenceObject)
                {
                    // specific protocol with a specific port
                    var cpObject = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                    protocolType,
                                                                                    ciscoAcl.DestinationProperties.TcpUdpPortOperator,
                                                                                    sPort,
                                                                                    ServiceDirection.Destination,
                                                                                    ciscoAcl.Id);
                    if (cpObject != null &&
                        (cpObject.GetType() == typeof(CheckPoint_TcpService) || cpObject.GetType() == typeof(CheckPoint_UdpService) || cpObject.GetType() == typeof(CheckPoint_OtherService)))
                    {
                        ApplyConversionIncidentOnCheckPointObject(cpObject, ciscoAcl);
                        AddCheckPointObject(cpObject);
                        cpRule.Service.Add(cpObject);
                    }
                }
                else
                {
                    // specific protocol with a service group of ports
                    CiscoCommand ciscoPortReferenceCommand = _ciscoParser.GetCommandByCiscoId(ciscoAcl.DestinationProperties.TcpUdpPortValue);

                    if (ciscoPortReferenceCommand.Name() == "object-group")
                    {
                        var ciscoGroupReferenceObject = (Cisco_GroupObject)ciscoPortReferenceCommand;

                        if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Service)
                        {
                            Add_AclPorts_To_CPRule(ciscoAcl, protocol, ciscoGroupReferenceObject, cpRule);
                        }
                    }
                }
            }
        }

        private void Add_AclPorts_To_CPRule(Cisco_AccessList ciscoAcl, string aclProtocol, Cisco_GroupObject aclPorts, CheckPoint_Rule cpRule)
        {
            foreach (Cisco_PortObject ciscoPort in aclPorts.GetChildPorts())
            {
                CheckPointObject cpObject;
                string serviceName;

                switch (aclProtocol)
                {
                    case "tcp-udp":
                        serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                        ProtocolType.Tcp,
                                                                                        TcpUdpPortOperatorType.Eq,
                                                                                        ciscoPort.Port,
                                                                                        ServiceDirection.Destination,
                                                                                        ciscoPort.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + aclPorts.CiscoId + ".");
                        cpRule.Service.Add(cpObject);

                        serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                        ProtocolType.Udp,
                                                                                        TcpUdpPortOperatorType.Eq,
                                                                                        ciscoPort.Port,
                                                                                        ServiceDirection.Destination,
                                                                                        ciscoPort.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + aclPorts.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                        break;

                    case "tcp":
                    case "udp":
                        serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                        aclProtocol,
                                                                                        "eq",
                                                                                        ciscoPort.Port,
                                                                                        ServiceDirection.Destination,
                                                                                        ciscoPort.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + aclPorts.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                        break;
                }
            }
        }

        private void Add_Layers_And_Rules_For_Other_Zones(CheckPoint_Package package)
        {
            var accessGroups = new List<string>();
            var accessGroupsExclude = new List<string>();
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;
                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Inbound)
                {
                    if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                    {
                        continue;
                    }
                    aclNames.Add(ciscoAccessGroup.AccessListName);

                    accessGroups.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                }
                else
                {
                    // No Outbound nor Global...
                    accessGroupsExclude.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                }
            }

            var availableZones = new List<CheckPoint_Zone>();
            int availableZonesWithZeroSecurityLevel = 0;

            foreach (CheckPoint_Zone cpZone in _cpZones)
            {
                if (accessGroups.Contains(cpZone.Name) || accessGroupsExclude.Contains(cpZone.Name))
                {
                    continue;
                }

                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);
                if (ciscoInterface == null || !ciscoInterface.HasValidIpAddress() || ciscoInterface.ManagementOnly)
                {
                    continue;
                }

                availableZones.Add(cpZone);

                // If the _isInterInterfaceTrafficAllowed flag is on and there are at least two Cisco interfaces with zero security level, 
                // we should add sub-policies for the equivalent CP zones to allow traffic between them.
                if (ciscoInterface.SecurityLevel == 0)
                {
                    ++availableZonesWithZeroSecurityLevel;
                }
            }

            foreach (CheckPoint_Zone cpZone in availableZones)
            {
                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);

                bool addSubPolicy = (_isIntraInterfaceTrafficAllowed || (_isInterInterfaceTrafficAllowed && availableZonesWithZeroSecurityLevel >= 2))
                                        ? (ciscoInterface.SecurityLevel >= 0)
                                        : (ciscoInterface.SecurityLevel > 0);

                if (addSubPolicy)
                {
                    var cpLayer = new CheckPoint_Layer();
                    cpLayer.Name = cpZone.Name + "_sub_policy";
                    cpLayer.IsAssociatedInterfaceDisabled = ciscoInterface.Shutdown;

                    if (_isIntraInterfaceTrafficAllowed)
                    {
                        var cpRule = new CheckPoint_Rule();
                        cpRule.ConversionComments = "Traffic allowed due to Cisco intra-interface configuration";
                        cpRule.Layer = cpLayer.Name;
                        cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                        cpRule.Source.Add(cpZone);
                        cpRule.Destination.Add(cpZone);

                        if (ciscoInterface.Shutdown)
                        {
                            cpRule.Enabled = false;
                        }

                        cpLayer.Rules.Add(cpRule);
                    }

                    // add rules to this sub policy
                    foreach (CiscoCommand command in CiscoInterfaceCommands)
                    {
                        var otherCiscoInterface = (Cisco_Interface)command;

                        if (string.IsNullOrEmpty(otherCiscoInterface.CiscoId) || 
                            otherCiscoInterface.CiscoId == ciscoInterface.CiscoId || 
                            !otherCiscoInterface.HasValidIpAddress() || 
                            otherCiscoInterface.ManagementOnly)
                        {
                            continue;
                        }

                        bool addRule = _isInterInterfaceTrafficAllowed
                                           ? (ciscoInterface.SecurityLevel >= otherCiscoInterface.SecurityLevel)
                                           : (ciscoInterface.SecurityLevel > otherCiscoInterface.SecurityLevel);

                        if (addRule)
                        {
                            var cpRule = new CheckPoint_Rule();
                            cpRule.ConversionComments = otherCiscoInterface.CiscoId + " security level " + otherCiscoInterface.SecurityLevel;
                            cpRule.Layer = cpLayer.Name;
                            cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                            cpRule.Destination.Add(_cpObjects.GetObject(otherCiscoInterface.CiscoId));

                            if (ciscoInterface.Shutdown || otherCiscoInterface.Shutdown)
                            {
                                cpRule.Enabled = false;
                            }

                            ApplyConversionIncidentOnCheckPointObject(cpRule, otherCiscoInterface);

                            cpLayer.Rules.Add(cpRule);
                        }
                    }

                    var cpCleanupRule = new CheckPoint_Rule();
                    cpCleanupRule.Name = CheckPoint_Rule.SubPolicyCleanupRuleName;
                    cpCleanupRule.Layer = cpLayer.Name;

                    cpLayer.Rules.Add(cpCleanupRule);

                    package.SubPolicies.Add(cpLayer);
                }
            }
        }

        private void DetectCheckPointFirewallRulesAffectedByInspectPolicy(CheckPoint_Package package)
        {
            var ciscoInspectedAclCommands = new List<Cisco_AccessList>();

            // Detect the affected ACLs
            foreach (var ciscoCommand in CiscoClassMapCommands)
            {
                var ciscoClassMapCommand = (Cisco_ClassMap)ciscoCommand;

                foreach (var matchedAclName in ciscoClassMapCommand.MatchedAclNames)
                {
                    foreach (CiscoCommand aclCommand in CiscoAclCommands)
                    {
                        var ciscoAcl = (Cisco_AccessList)aclCommand;
                        if (!ciscoAcl.IsRemark && ciscoAcl.ACLName == matchedAclName)
                        {
                            ciscoAcl.Tag = ciscoClassMapCommand.ClassMapName;
                            ciscoInspectedAclCommands.Add(ciscoAcl);
                        }
                    }
                }
            }

            // Go over the affected ACLs and match the fw rules by: source, destination and service fields
            foreach (var ciscoInspectedAcl in ciscoInspectedAclCommands)
            {
                var inspectedRule = Acl_To_CPRule(ciscoInspectedAcl);

                if ((inspectedRule.Source.Count == 1 && inspectedRule.Source[0].Name == CheckPointObject.Any) &&
                    (inspectedRule.Destination.Count == 1 && inspectedRule.Destination[0].Name == CheckPointObject.Any) &&
                    (inspectedRule.Service.Count == 1 && inspectedRule.Service[0].Name == CheckPointObject.Any))
                {
                    continue;   // cisco any/any/any??? skip!!!
                }

                bool foundMatchedRules = false;

                foreach (CheckPoint_Rule cpParentRule in package.ParentLayer.Rules)
                {
                    if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                    {
                        continue;
                    }

                    // Skip automatic rules for interfaces without access-group
                    if (cpParentRule.SubPolicyName.EndsWith("_sub_policy"))
                    {
                        continue;
                    }

                    // Get into the relevant sub-policy
                    foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                    {
                        if (subPolicy.Name != cpParentRule.SubPolicyName)
                        {
                            continue;
                        }

                        for (int ruleNumber = 0; ruleNumber < subPolicy.Rules.Count; ruleNumber++)
                        {
                            var cpRule = subPolicy.Rules[ruleNumber];

                            // Do not match on cleanup rule!!!
                            if (cpRule.IsCleanupRule())
                            {
                                continue;
                            }

                            // Do not match if rule's destination is 'any'
                            if (cpRule.Destination.Count == 1 && cpRule.Destination[0].Name == CheckPointObject.Any)
                            {
                                continue;
                            }

                            if (IsCheckPointFirewallRuleMatchedByInspectPolicy(cpRule, inspectedRule))
                            {
                                if (string.IsNullOrEmpty(cpRule.Tag))
                                {
                                    cpRule.Tag = ciscoInspectedAcl.Tag;   // Cisco Class-Map object name
                                }
                                else
                                {
                                    // There may be several class-maps (e.g: class1, class2, ...) matching the same fw rule...
                                    // BUT - do not tag on the SAME class-map (e.g: class1) multiple times!!!
                                    if (!cpRule.Tag.Contains(ciscoInspectedAcl.Tag))
                                    {
                                        cpRule.Tag += ",";
                                        cpRule.Tag += ciscoInspectedAcl.Tag;   // Cisco Class-Map object name
                                    }
                                }

                                foundMatchedRules = true;
                            }
                        }
                    }
                }

                if (foundMatchedRules)
                {
                    package.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoInspectedAcl.Id,
                                                                    "Check Point firewall rules traffic is affected by Cisco inspect policy",
                                                                    "Cisco class-map object: " + ciscoInspectedAcl.Tag + ". For rules details refer to the Converted Policy Report.",
                                                                    ConversionIncidentType.Informative));
                }
            }
        }

        private bool IsCheckPointFirewallRuleMatchedByInspectPolicy(CheckPoint_Rule fwRule, CheckPoint_Rule inspectedRule)
        {
            // Do not match on any/any/any rule!!!
            // There may be such rules due to usage of generic IP protocol as a service in ACL...
            if ((fwRule.Source.Count == 1 && fwRule.Source[0].Name == CheckPointObject.Any) &&
                (fwRule.Destination.Count == 1 && fwRule.Destination[0].Name == CheckPointObject.Any) &&
                (fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any))
            {
                return false;
            }

            var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
            var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();
            var inspectedRuleSourceRanges = (inspectedRule.Source.Count > 0) ? GetRanges(inspectedRule.Source[0]) : IPRanges.Any();
            var inspectedRuleDestRanges = (inspectedRule.Destination.Count > 0) ? GetRanges(inspectedRule.Destination[0]) : IPRanges.Any();

            if (inspectedRuleSourceRanges.Overlaps(fwRuleSourceRanges) && inspectedRuleDestRanges.Overlaps(fwRuleDestRanges))
            {
                if ((fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any) ||
                    (inspectedRule.Service.Count == 1 && inspectedRule.Service[0].Name == CheckPointObject.Any))
                {
                    return true;
                }

                // Inspected services should be a subset of fw services
                foreach (var inspectedService in inspectedRule.Service)
                {
                    bool matchService = fwRule.Service.Any(fwService => fwService.Name == inspectedService.Name);
                    if (!matchService)
                    {
                        return false;
                    }
                }

                return true;
            }

            return false;
        }

        private void Add_object_NAT()
        {
            foreach (Cisco_Object command in CiscoObjectCommands)
            {
                if (command.Children == null)
                {
                    continue;
                }

                foreach (CiscoCommand childCommand in command.Children)
                {
                    // This is for object-NAT only
                    if (childCommand.Name() == "nat")
                    {
                        var ciscoNat = (Cisco_Nat)childCommand;

                        var cpNatRule = new CheckPoint_NAT_Rule();
                        cpNatRule.Enabled = !ciscoNat.Inactive;
                        cpNatRule.Interface1 = ciscoNat.RealInterface;
                        cpNatRule.Interface2 = ciscoNat.MappedInterface;
                        cpNatRule.Method = ciscoNat.IsStatic ? CheckPoint_NAT_Rule.NatMethod.Static : CheckPoint_NAT_Rule.NatMethod.Hide;
                        cpNatRule.Source = _cpObjects.GetObject(command.CiscoId);
                        cpNatRule.Comments = command.Id + ")" + (ciscoNat.IsStatic ? " Static " : " Dynamic ") + "object NAT for " + command.CiscoId;
                        cpNatRule.IsObjectNatRule = true;

                        ApplyConversionIncidentOnCheckPointObject(cpNatRule, ciscoNat);

                        string translatedSourceName;

                        string ciscoNetworkObjectName = ciscoNat.IsStatic ? ciscoNat.StaticNatIpAddressOrObjectName : ciscoNat.DynamicNatIpAddressOrObjectName;
                        var ciscoNetworkObject = _ciscoParser.GetCommandByCiscoId(ciscoNetworkObjectName);

                        if (ciscoNetworkObject != null)   // mapped_object_name
                        {
                            // Should be a host/network/range object only.
                            if (ciscoNetworkObject.GetType() == typeof(Cisco_Object))
                            {
                                var ciscoNetwork = (Cisco_Object)ciscoNetworkObject;

                                switch (ciscoNetwork.ObjectType)
                                {
                                    case Cisco_Object.ObjectTypes.Host:
                                        {
                                            var network = new CiscoNetwork(ciscoNat.Id, ciscoNetwork.HostAddress);

                                            var cpHostTranslated = new CheckPoint_Host();
                                            cpHostTranslated.Name = network.AutoGeneratedName();
                                            cpHostTranslated.IpAddress = network.IpAddress;
                                            ApplyConversionIncidentOnCheckPointObject(cpHostTranslated, ciscoNat);
                                            AddCheckPointObject(cpHostTranslated);

                                            translatedSourceName = cpHostTranslated.Name;
                                        }
                                        break;

                                    case Cisco_Object.ObjectTypes.Network:
                                        {
                                            var network = new CiscoNetwork(ciscoNat.Id, ciscoNetwork.Network, ciscoNetwork.Netmask);

                                            var cpNetworkTranslated = new CheckPoint_Network();
                                            cpNetworkTranslated.Name = network.AutoGeneratedName();
                                            cpNetworkTranslated.Subnet = network.IpAddress;
                                            cpNetworkTranslated.Netmask = network.NetMask;
                                            ApplyConversionIncidentOnCheckPointObject(cpNetworkTranslated, ciscoNat);
                                            AddCheckPointObject(cpNetworkTranslated);

                                            translatedSourceName = cpNetworkTranslated.Name;
                                        }
                                        break;

                                    case Cisco_Object.ObjectTypes.Range:
                                        {
                                            var cpRangeTranslated = new CheckPoint_Range();
                                            cpRangeTranslated.Name = "r_" + ciscoNetwork.RangeFrom + "-" + ciscoNetwork.RangeTo;
                                            cpRangeTranslated.RangeFrom = ciscoNetwork.RangeFrom;
                                            cpRangeTranslated.RangeTo = ciscoNetwork.RangeTo;
                                            ApplyConversionIncidentOnCheckPointObject(cpRangeTranslated, ciscoNat);
                                            AddCheckPointObject(cpRangeTranslated);

                                            translatedSourceName = cpRangeTranslated.Name;
                                        }
                                        break;

                                    default:
                                        {
                                            var cpError = GetCheckPointObjectOrCreateDummy(ciscoNetwork.ObjectType.ToString(),
                                                                                           CheckPointDummyObjectType.Host,
                                                                                           ciscoNat,
                                                                                           "Error creating a NAT rule, missing information for Cisco translated source",
                                                                                           "Translated source details: " + ciscoNetworkObjectName + ".");
                                            translatedSourceName = cpError.Name;
                                        }
                                        break;
                                }
                            }
                            else
                            {
                                var cpError = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                               CheckPointDummyObjectType.Host,
                                                                               ciscoNat,
                                                                               "Error creating a NAT rule, group object cannot be used as a translated source",
                                                                               "Group object details: " + ciscoNetworkObjectName + ".");
                                translatedSourceName = cpError.Name;
                            }
                        }
                        else
                        {
                            if (ciscoNat.IsHideBehindInterface)   // interface
                            {
                                // No need for translated source for NAT hidden behind an interface...
                                translatedSourceName = "";
                            }
                            else   // mapped_host_ip_address
                            {
                                // Can be a host IP address only.
                                var network = new CiscoNetwork(ciscoNat.Id, ciscoNat.IsStatic ? ciscoNat.StaticNatIpAddressOrObjectName : ciscoNat.DynamicNatIpAddressOrObjectName);

                                var cpHostTranslated = new CheckPoint_Host();
                                cpHostTranslated.Name = network.AutoGeneratedName();
                                cpHostTranslated.IpAddress = network.IpAddress;
                                ApplyConversionIncidentOnCheckPointObject(cpHostTranslated, ciscoNat);
                                AddCheckPointObject(cpHostTranslated);

                                translatedSourceName = cpHostTranslated.Name;
                            }
                        }

                        if (ciscoNat.IsHideBehindInterface)
                        {
                            cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_address",
                                                                                          CheckPointDummyObjectType.Host,
                                                                                          ciscoNat,
                                                                                          "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                          "Interface details: " + ciscoNat.MappedInterface + ".");
                        }
                        else   // hide behind an arbitrary ip/network
                        {
                            cpNatRule.TranslatedSource = _cpObjects.GetObject(translatedSourceName);
                        }

                        if (ciscoNat.MappedInterface == CiscoCommand.Any)
                        {
                            cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                        }
                        else
                        {
                            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                            if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                            {
                                cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                                cpNatRule.IsNonNatSectionRule = true;
                            }
                            else
                            {
                                cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_subnets",
                                                                                         CheckPointDummyObjectType.NetworkGroup,
                                                                                         ciscoNat,
                                                                                         "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                         "Interface details: " + ciscoNat.MappedInterface + ".");
                            }
                        }

                        if (ciscoNat.IsStatic && !string.IsNullOrEmpty(ciscoNat.ServiceProtocol))
                        {
                            CheckPointObject cpService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                          (ciscoNat.ServiceProtocol == "tcp") ? ProtocolType.Tcp : ProtocolType.Udp,
                                                                                                          TcpUdpPortOperatorType.Eq,
                                                                                                          ciscoNat.ServiceId,
                                                                                                          ServiceDirection.Destination,
                                                                                                          ciscoNat.Id);
                            ApplyConversionIncidentOnCheckPointObject(cpService, ciscoNat);
                            AddCheckPointObject(cpService);

                            cpNatRule.Service = cpService;

                            if (ciscoNat.ServiceId != ciscoNat.TranslatedServiceId)
                            {
                                CheckPointObject cpTranslatedService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                                        (ciscoNat.ServiceProtocol == "tcp") ? ProtocolType.Tcp : ProtocolType.Udp,
                                                                                                                        TcpUdpPortOperatorType.Eq,
                                                                                                                        ciscoNat.TranslatedServiceId,
                                                                                                                        ServiceDirection.Destination,
                                                                                                                        ciscoNat.Id);
                                ApplyConversionIncidentOnCheckPointObject(cpTranslatedService, ciscoNat);
                                AddCheckPointObject(cpTranslatedService);

                                cpNatRule.TranslatedService = cpTranslatedService;
                            }
                        }

                        bool natRuleObjectHasConversionIncident = (cpNatRule.Source != null && cpNatRule.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.Destination != null && cpNatRule.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.TranslatedDestination != null && cpNatRule.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.Service != null && cpNatRule.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.TranslatedService != null && cpNatRule.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                        _cpPreorderedNatRules.Add(cpNatRule);

                        if (cpNatRule.ConversionIncidentType != ConversionIncidentType.None || 
                            ciscoNat.ConversionIncidentType != ConversionIncidentType.None || 
                            natRuleObjectHasConversionIncident)
                        {
                            _hasNATConversionIncident = true;
                        }

                        // Mirrored NAT rule
                        if (ciscoNat.IsStatic && !ciscoNat.IsUnidirectional)
                        {
                            var cpNatMirrorRule = new CheckPoint_NAT_Rule();
                            cpNatMirrorRule.Enabled = cpNatRule.Enabled;
                            cpNatMirrorRule.Interface1 = ciscoNat.MappedInterface;
                            cpNatMirrorRule.Interface2 = ciscoNat.RealInterface;
                            cpNatMirrorRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                            cpNatMirrorRule.IsStaticMirrorRule = true;
                            cpNatMirrorRule.Source = cpNatRule.Destination;
                            cpNatMirrorRule.Destination = cpNatRule.TranslatedSource;
                            cpNatMirrorRule.Service = cpNatRule.TranslatedService ?? cpNatRule.Service;
                            cpNatMirrorRule.TranslatedDestination = _cpObjects.GetObject(command.CiscoId);
                            cpNatMirrorRule.TranslatedService = (cpNatRule.TranslatedService != null) ? cpNatRule.Service : cpNatRule.TranslatedService;
                            cpNatMirrorRule.Comments = "Mirror rule for object " + command.CiscoId;
                            cpNatMirrorRule.IsObjectNatRule = true;
                            cpNatMirrorRule.IsNonNatSectionRule = cpNatRule.IsNonNatSectionRule;

                            _cpPreorderedNatRules.Add(cpNatMirrorRule);
                        }
                    }
                }
            }
        }

        private void Add_NAT_Rules()
        {
            // This is for manual-NAT, twice-NAT and auto-after-manual-twice-NAT
            List<CiscoCommand> natCommands = _ciscoParser.Filter("nat");

            foreach (CiscoCommand command in natCommands)
            {
                var ciscoNat = (Cisco_Nat)command;

                Add_IP_as_Host(ciscoNat.Id, ciscoNat.SourceId);
                if (!ciscoNat.IsHideBehindInterface)
                {
                    Add_IP_as_Host(ciscoNat.Id, ciscoNat.TranslatedSourceId);
                }
                Add_IP_as_Host(ciscoNat.Id, ciscoNat.DestinationId);
                Add_IP_as_Host(ciscoNat.Id, ciscoNat.TranslatedDestinationId);

                // Original NAT rule
                var cpNatRule = new CheckPoint_NAT_Rule();
                cpNatRule.Enabled = !ciscoNat.Inactive;
                cpNatRule.Interface1 = ciscoNat.RealInterface;
                cpNatRule.Interface2 = ciscoNat.MappedInterface;
                cpNatRule.Method = ciscoNat.IsStatic ? CheckPoint_NAT_Rule.NatMethod.Static : CheckPoint_NAT_Rule.NatMethod.Hide;
                cpNatRule.IsAutoAfterSectionRule = ciscoNat.IsAutoAfter;
                cpNatRule.Comments = ciscoNat.Id + ") " + ciscoNat.Text;

                if (ciscoNat.SourceId == ciscoNat.TranslatedSourceId && ciscoNat.DestinationId == ciscoNat.TranslatedDestinationId)
                {
                    cpNatRule.IsNonNatRule = true;
                }

                ApplyConversionIncidentOnCheckPointObject(cpNatRule, ciscoNat);

                // Source
                if (ciscoNat.SourceId != CiscoCommand.Any)
                {
                    cpNatRule.Source = GetCheckPointObjectOrCreateDummy(ciscoNat.SourceId,
                                                                        CheckPointDummyObjectType.NetworkGroup,
                                                                        ciscoNat,
                                                                        "Error creating a NAT rule, missing information for Cisco source",
                                                                        "Source details: " + ciscoNat.SourceId + ".");

                    if (ciscoNat.RealInterface != CiscoCommand.Any)
                    {
                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.RealInterface);
                        if (ciscoInterface == null)
                        {
                            cpNatRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                            ciscoNat.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                            _conversionIncidents.Add(new ConversionIncident(ciscoNat.Id,
                                                                            "Error creating a NAT rule, missing information for Cisco interface",
                                                                            "Interface details: " + ciscoNat.RealInterface + ".",
                                                                            ciscoNat.ConversionIncidentType));
                        }
                        else if (ciscoInterface.LeadsToInternet)
                        {
                            cpNatRule.IsNonNatSectionRule = true;
                        }
                    }
                }
                else   // Identity NAT ???
                {
                    if (ciscoNat.RealInterface == CiscoCommand.Any)
                    {
                        cpNatRule.Source = _cpObjects.GetObject(CheckPointObject.Any);
                    }
                    else
                    {
                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.RealInterface);
                        if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                        {
                            cpNatRule.Source = _cpObjects.GetObject(CheckPointObject.Any);
                            cpNatRule.IsNonNatSectionRule = true;
                        }
                        else
                        {
                            cpNatRule.Source = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.RealInterface + "_subnets",
                                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                                ciscoNat,
                                                                                "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                "Interface details: " + ciscoNat.RealInterface + ".");
                        }
                    }
                }

                // Destination
                if (string.IsNullOrEmpty(ciscoNat.DestinationId))   // Manual NAT
                {
                    if (ciscoNat.MappedInterface == CiscoCommand.Any)
                    {
                        cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                    }
                    else
                    {
                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                        if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                        {
                            cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                            cpNatRule.IsNonNatSectionRule = true;
                        }
                        else
                        {
                            cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_subnets",
                                                                                     CheckPointDummyObjectType.NetworkGroup,
                                                                                     ciscoNat,
                                                                                     "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                     "Interface details: " + ciscoNat.MappedInterface + ".");
                        }
                    }
                }
                else   // Twice NAT
                {
                    if (ciscoNat.DestinationId != CiscoCommand.Any)
                    {
                        cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(ciscoNat.DestinationId,
                                                                                 CheckPointDummyObjectType.NetworkGroup,
                                                                                 ciscoNat,
                                                                                 "Error creating a NAT rule, missing information for Cisco destination",
                                                                                 "Destination details: " + ciscoNat.DestinationId + ".");

                        if (ciscoNat.MappedInterface != CiscoCommand.Any)
                        {
                            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                            if (ciscoInterface == null)
                            {
                                cpNatRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                ciscoNat.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                                _conversionIncidents.Add(new ConversionIncident(ciscoNat.Id,
                                                                                "Error creating a NAT rule, missing information for Cisco interface",
                                                                                "Interface details: " + ciscoNat.MappedInterface + ".",
                                                                                ciscoNat.ConversionIncidentType));
                            }
                            else if (ciscoInterface.LeadsToInternet)
                            {
                                cpNatRule.IsNonNatSectionRule = true;
                            }
                        }
                    }
                    else
                    {
                        if (ciscoNat.MappedInterface == CiscoCommand.Any)
                        {
                            cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                        }
                        else
                        {
                            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                            if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                            {
                                cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                                cpNatRule.IsNonNatSectionRule = true;
                            }
                            else
                            {
                                cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_subnets",
                                                                                         CheckPointDummyObjectType.NetworkGroup,
                                                                                         ciscoNat,
                                                                                         "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                         "Interface details: " + ciscoNat.MappedInterface + ".");
                            }
                        }
                    }
                }

                // Service
                if (!string.IsNullOrEmpty(ciscoNat.ServiceId))
                {
                    cpNatRule.Service = GetCheckPointObjectOrCreateDummy(ciscoNat.ServiceId,
                                                                         CheckPointDummyObjectType.ServiceGroup,
                                                                         ciscoNat,
                                                                         "Error creating a NAT rule, missing information for Cisco service",
                                                                         "Service details: " + ciscoNat.ServiceId + ".");
                }

                // Translated source
                if (ciscoNat.IsHideBehindInterface)
                {
                    cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_address",
                                                                                  CheckPointDummyObjectType.Host,
                                                                                  ciscoNat,
                                                                                  "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                  "Interface details: " + ciscoNat.MappedInterface + ".");
                }
                else if (ciscoNat.SourceId != ciscoNat.TranslatedSourceId && ciscoNat.TranslatedSourceId != CiscoCommand.Any)
                {
                    cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummy(ciscoNat.TranslatedSourceId,
                                                                                  CheckPointDummyObjectType.Host,
                                                                                  ciscoNat,
                                                                                  "Error creating a NAT rule, missing information for Cisco translated source",
                                                                                  "Translated source details: " + ciscoNat.TranslatedSourceId + ".");
                }

                // Translated destination for Twice NAT only
                if (ciscoNat.DestinationId != ciscoNat.TranslatedDestinationId && ciscoNat.TranslatedDestinationId != CiscoCommand.Any)
                {
                    cpNatRule.TranslatedDestination = GetCheckPointObjectOrCreateDummy(ciscoNat.TranslatedDestinationId,
                                                                                       CheckPointDummyObjectType.Host,
                                                                                       ciscoNat,
                                                                                       "Error creating a NAT rule, missing information for Cisco translated destination",
                                                                                       "Translated destination details: " + ciscoNat.TranslatedDestinationId + ".");
                }

                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                // If NAT source/destination/translated source/translated destination is a group object and there is only one member in the group,
                // then use object rather than group.
                // In case of NAT translated source/translated destination we should create an error host object because group cannot be used here!!!
                if (cpNatRule.Source != null && cpNatRule.Source.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.Source = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.Source, ciscoNat, false);
                }
                if (cpNatRule.Destination != null && cpNatRule.Destination.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.Destination = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.Destination, ciscoNat, false);
                }
                if (cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.TranslatedSource, ciscoNat);
                }
                if (cpNatRule.TranslatedDestination != null && cpNatRule.TranslatedDestination.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.TranslatedDestination = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.TranslatedDestination, ciscoNat);
                }
                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                // Translated Service
                if (ciscoNat.ServiceId != ciscoNat.TranslatedServiceId)
                {
                    cpNatRule.TranslatedService = GetCheckPointObjectOrCreateDummy(ciscoNat.TranslatedServiceId,
                                                                                   CheckPointDummyObjectType.ServiceGroup,
                                                                                   ciscoNat,
                                                                                   "Error creating a NAT rule, missing information for Cisco  translated service",
                                                                                   "Translated service details: " + ciscoNat.TranslatedServiceId + ".");
                }

                // Static NAT: if a source is a network or a network group and a translated source is a host, 
                // we should convert to dynamic NAT rule!!!
                if (cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
                {
                    if ((cpNatRule.Source.GetType() == typeof(CheckPoint_Network) || cpNatRule.Source.GetType() == typeof(CheckPoint_NetworkGroup)) && 
                        cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.GetType() == typeof(CheckPoint_Host))
                    {
                        cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Hide;
                        ciscoNat.IsStatic = false;
                    }
                }

                bool natRuleObjectHasConversionIncident = (cpNatRule.Source != null && cpNatRule.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.Destination != null && cpNatRule.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.TranslatedDestination != null && cpNatRule.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.Service != null && cpNatRule.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.TranslatedService != null && cpNatRule.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                _cpPreorderedNatRules.Add(cpNatRule);

                if (cpNatRule.ConversionIncidentType != ConversionIncidentType.None || 
                    ciscoNat.ConversionIncidentType != ConversionIncidentType.None || 
                    natRuleObjectHasConversionIncident)
                {
                    _hasNATConversionIncident = true;
                }

                // Mirrored NAT rule for Static NAT
                if (ciscoNat.IsStatic && !ciscoNat.IsUnidirectional)
                {
                    var cpNatMirrorRule = new CheckPoint_NAT_Rule();
                    cpNatMirrorRule.Enabled = cpNatRule.Enabled;
                    cpNatMirrorRule.Interface1 = ciscoNat.MappedInterface;
                    cpNatMirrorRule.Interface2 = ciscoNat.RealInterface;
                    cpNatMirrorRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                    cpNatMirrorRule.IsStaticMirrorRule = true;

                    if (cpNatRule.IsNonNatRule)
                    {
                        cpNatMirrorRule.Source = cpNatRule.Destination;
                        cpNatMirrorRule.Destination = cpNatRule.Source;
                    }
                    else
                    {
                        cpNatMirrorRule.Source = cpNatRule.TranslatedDestination ?? cpNatRule.Destination;
                        cpNatMirrorRule.Destination = cpNatRule.TranslatedSource ?? cpNatRule.Source;
                        if (!string.IsNullOrEmpty(ciscoNat.DestinationId))
                        {
                            cpNatMirrorRule.TranslatedSource = cpNatRule.Destination;
                        }
                        if (ciscoNat.SourceId != ciscoNat.TranslatedSourceId)
                        {
                            cpNatMirrorRule.TranslatedDestination = cpNatRule.Source;
                        }

                        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        // Network group cannot be used as NAT translated source/destination!!!
                        // Remediation:
                        // if only one member object in group, then use object rather than group,
                        // otherwise create an error host object.
                        if (cpNatMirrorRule.TranslatedSource != null && cpNatMirrorRule.TranslatedSource.GetType() == typeof(CheckPoint_NetworkGroup))
                        {
                            cpNatMirrorRule.TranslatedSource = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatMirrorRule.TranslatedSource, ciscoNat);
                        }
                        if (cpNatMirrorRule.TranslatedDestination != null && cpNatMirrorRule.TranslatedDestination.GetType() == typeof(CheckPoint_NetworkGroup))
                        {
                            cpNatMirrorRule.TranslatedDestination = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatMirrorRule.TranslatedDestination, ciscoNat);
                        }
                        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    }

                    cpNatMirrorRule.Service = cpNatRule.TranslatedService ?? cpNatRule.Service;
                    cpNatMirrorRule.TranslatedService = (cpNatRule.TranslatedService != null) ? cpNatRule.Service : cpNatRule.TranslatedService;
                    cpNatMirrorRule.Comments = string.Format("Mirror rule for {0}", ciscoNat.Id);
                    cpNatMirrorRule.IsNonNatSectionRule = cpNatRule.IsNonNatSectionRule;
                    cpNatMirrorRule.IsAutoAfterSectionRule = cpNatRule.IsAutoAfterSectionRule;

                    _cpPreorderedNatRules.Add(cpNatMirrorRule);

                    if (cpNatMirrorRule.ConversionIncidentType != ConversionIncidentType.None || 
                        ciscoNat.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        _hasNATConversionIncident = true;
                    }
                }
            }
        }

        private void Add_IP_as_Host(int ciscoCommandId, string sIp)
        {
            // The order of this condition check is important!!!
            if (string.IsNullOrEmpty(sIp) || _cpObjects.HasObject(sIp) || !NetworkUtils.IsValidIp(sIp))
            {
                return;
            }

            var network = new CiscoNetwork(ciscoCommandId, sIp);

            var cpHost = new CheckPoint_Host();
            cpHost.Name = network.AutoGeneratedName();
            cpHost.IpAddress = network.IpAddress;
            cpHost.ConvertedCommandId = ciscoCommandId;
            AddCheckPointObject(cpHost);
        }

        private void CreateNATRulebase()
        {
            var section1 = new List<CheckPoint_NAT_Rule>();
            var section2Static = new List<CheckPoint_NAT_Rule>();
            var section2Dynamic = new List<CheckPoint_NAT_Rule>();
            var section3 = new List<CheckPoint_NAT_Rule>();
            var section5 = new List<CheckPoint_NAT_Rule>();
            var section6Static = new List<CheckPoint_NAT_Rule>();
            var section6Dynamic = new List<CheckPoint_NAT_Rule>();
            var section7 = new List<CheckPoint_NAT_Rule>();

            // Create the NAT sections
            foreach (var cpNatRule in _cpPreorderedNatRules)
            {
                // Create section #1:
                // Manual and twice NAT rules --> no Non-NAT and no auto-after and no object-NAT
                if (!cpNatRule.IsNonNatSectionRule && !cpNatRule.IsAutoAfterSectionRule && !cpNatRule.IsObjectNatRule)
                {
                    section1.Add(cpNatRule);
                }

                // Create section #2.1:
                // Object NAT rules - static --> no Non-NAT and no auto-after
                if (!cpNatRule.IsNonNatSectionRule && !cpNatRule.IsAutoAfterSectionRule && cpNatRule.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
                {
                    section2Static.Add(cpNatRule);
                }

                // Create section #2.2:
                // Object NAT rules - dynamic --> no Non-NAT and no auto-after
                if (!cpNatRule.IsNonNatSectionRule && !cpNatRule.IsAutoAfterSectionRule && cpNatRule.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                {
                    section2Dynamic.Add(cpNatRule);
                }

                // Create section #3:
                // Auto-After manual and twice NAT rules --> no Non-NAT and no object-NAT
                if (!cpNatRule.IsNonNatSectionRule && cpNatRule.IsAutoAfterSectionRule && !cpNatRule.IsObjectNatRule)
                {
                    section3.Add(cpNatRule);
                }

                // Create section #5:
                // Non-NAT manual and twice NAT rules --> no auto-after and no object-NAT
                if (cpNatRule.IsNonNatSectionRule && !cpNatRule.IsAutoAfterSectionRule && !cpNatRule.IsObjectNatRule)
                {
                    section5.Add(cpNatRule);
                }

                // Create section #6.1:
                // Non-NAT object NAT rules - static --> no auto-after
                if (cpNatRule.IsNonNatSectionRule && !cpNatRule.IsAutoAfterSectionRule && cpNatRule.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
                {
                    section6Static.Add(cpNatRule);
                }

                // Create section #6.2:
                // Non-NAT object NAT rules - dynamic --> no auto-after
                if (cpNatRule.IsNonNatSectionRule && !cpNatRule.IsAutoAfterSectionRule && cpNatRule.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                {
                    section6Dynamic.Add(cpNatRule);
                }

                // Create section #7:
                // Non-NAT auto-After manual and twice NAT rules --> no object-NAT
                if (cpNatRule.IsNonNatSectionRule && cpNatRule.IsAutoAfterSectionRule && !cpNatRule.IsObjectNatRule)
                {
                    section7.Add(cpNatRule);
                }
            }

            // Create the NAT Rulebase
            _cpNatRules.AddRange(section1);
            _cpNatRules.AddRange(section2Static);
            _cpNatRules.AddRange(section2Dynamic);
            _cpNatRules.AddRange(section3);

            // Do we need Non-NAT sections?
            if (section5.Any() || section6Static.Any() || section6Dynamic.Any() || section7.Any())
            {
                // Create section #4:
                // A single Non-NATs top rule
                var section4 = new CheckPoint_NAT_Rule();
                section4.Comments = "Auto-generated rule above interfaces that lead to the internet";
                section4.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                section4.Source = _cpObjects.GetObject(AllInternalNetwotkGroupName);
                section4.Destination = _cpObjects.GetObject(AllInternalNetwotkGroupName);
                _cpNatRules.Add(section4);

                _cpNatRules.AddRange(section5);
                _cpNatRules.AddRange(section6Static);
                _cpNatRules.AddRange(section6Dynamic);
                _cpNatRules.AddRange(section7);
            }
        }

        private void MatchNATRulesIntoFirewallPolicy()
        {
            CheckPoint_Package cpPackage = _cpPackages[0];

            foreach (CheckPoint_NAT_Rule cpNatRule in _cpNatRules)
            {
                if (!cpNatRule.Enabled)
                {
                    continue;
                }

                // For example, NAT section #4 rule...
                if (cpNatRule.TranslatedSource == null && cpNatRule.TranslatedDestination == null)
                {
                    continue;
                }

                // Skip dynamic object-NAT rules
                if (cpNatRule.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                {
                    continue;
                }

                // Skip dynamic manual-NAT rules
                if (!cpNatRule.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide && cpNatRule.TranslatedDestination == null)
                {
                    continue;
                }

                // Skip static NAT mirrored rules
                if (cpNatRule.IsStaticMirrorRule)
                {
                    continue;
                }

                // Skip Non-NAT rules (only twice-NAT: SourceId == TranslatedSourceId && DestinationId == TranslatedDestinationId)
                if (cpNatRule.IsNonNatRule)
                {
                    continue;
                }

                string natRuleInterface1 = (cpNatRule.Interface1 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + cpNatRule.Interface1) : cpNatRule.Interface1;
                string natRuleInterface2 = (cpNatRule.Interface2 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + cpNatRule.Interface2) : cpNatRule.Interface2;

                foreach (CheckPoint_Rule cpParentRule in cpPackage.ParentLayer.Rules)
                {
                    if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                    {
                        continue;
                    }

                    var parentLayerRuleZone = (CheckPoint_Zone)cpParentRule.Source[0];
                    if (parentLayerRuleZone == null)
                    {
                        Console.WriteLine("Ooopppsssss...............");   // shouldn't happen...
                        continue;
                    }

                    // NAT rule interfaces should match on firewall rule interfaces (zones)
                    if (natRuleInterface1 != CiscoCommand.Any && natRuleInterface1 != parentLayerRuleZone.Name &&
                        natRuleInterface2 != CiscoCommand.Any && natRuleInterface2 != parentLayerRuleZone.Name)
                    {
                        continue;
                    }

                    // Get into the relevant sub-policy
                    foreach (CheckPoint_Layer subPolicy in cpPackage.SubPolicies)
                    {
                        if (subPolicy.Name != cpParentRule.SubPolicyName)
                        {
                            continue;
                        }

                        for (int ruleNumber = 0; ruleNumber < subPolicy.Rules.Count; ruleNumber++)
                        {
                            var cpRule = subPolicy.Rules[ruleNumber];

                            // Do not match on cleanup rule
                            if (cpRule.IsCleanupRule())
                            {
                                continue;
                            }

                            // Do not match if rule's destination is 'any'
                            if (cpRule.Destination.Count == 1)
                            {
                                string destinationName = cpRule.Destination[0].Name;
                                if (destinationName == CheckPointObject.Any)
                                {
                                    continue;
                                }

                                if (destinationName.StartsWith(CiscoCommand.InterfacePrefix))
                                {
                                    // get Cisco interface object
                                    var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(destinationName);
                                    if (ciscoInterface != null && (ciscoInterface.LeadsToInternet || ciscoInterface.SecurityLevel == 0))
                                    {
                                        continue;
                                    }
                                }
                            }

                            CheckPointObject newRuleDest = null;
                            bool serviceMatchedToo = false;

                            if (IsFirewallRuleMatchedByNATRule(parentLayerRuleZone, cpNatRule, cpRule, out newRuleDest, out serviceMatchedToo))
                            {
                                string translatedSourceName = (cpNatRule.TranslatedSource != null) ? cpNatRule.TranslatedSource.Name : "original";
                                string translatedDestName = (cpNatRule.TranslatedDestination != null) ? cpNatRule.TranslatedDestination.Name : "original";
                                string translatedServiceName = (cpNatRule.TranslatedService != null) ?
                                                               cpNatRule.TranslatedService.Name : (cpNatRule.Service != null ? cpNatRule.Service.Name : "");

                                var newRule = new CheckPoint_Rule();

                                newRule.Enabled = cpRule.Enabled;
                                newRule.Source.AddRange(cpRule.Source);
                                newRule.Destination.Add(newRuleDest);
                                if (serviceMatchedToo)
                                {
                                    newRule.Service.Add(_cpObjects.GetObject(translatedServiceName));
                                }
                                else
                                {
                                    newRule.Service.AddRange(cpRule.Service);
                                }
                                newRule.Time.AddRange(cpRule.Time);
                                newRule.Action = cpRule.Action;
                                newRule.Layer = subPolicy.Name;
                                newRule.ConvertedCommandId = cpNatRule.ConvertedCommandId;
                                newRule.ConversionIncidentType = (cpRule.ConversionIncidentType != ConversionIncidentType.None) ? cpRule.ConversionIncidentType : cpNatRule.ConversionIncidentType;
                                if (serviceMatchedToo)
                                {
                                    translatedServiceName = (cpNatRule.TranslatedService != null) ? cpNatRule.TranslatedService.Name : "original";
                                    newRule.ConversionComments = "Matched NAT rule ((" + cpNatRule.ConvertedCommandId + ") translated source: " + translatedSourceName + ", translated dest: " + translatedDestName + ", translated service: " + translatedServiceName + ")";
                                }
                                else
                                {
                                    newRule.ConversionComments = "Matched NAT rule ((" + cpNatRule.ConvertedCommandId + ") translated source: " + translatedSourceName + ", translated dest: " + translatedDestName + ")";
                                }

                                // Add a new rule ABOVE the matched rule.
                                subPolicy.Rules.Insert(ruleNumber, newRule);

                                if (newRule.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    cpPackage.ConversionIncidentType = ConversionIncidentType.Informative;
                                }

                                // If NAT rule's service is "any" (null), we need to keep matching for all relevant FW rules.
                                if (serviceMatchedToo)
                                {
                                    break;
                                }
                                else
                                {
                                    ++ruleNumber;   // this is because we are changing the collection during iteration!!!
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// !!! This method's logic follows the instructions from the "NAT rules matching FlowChart.vsd" document !!!
        /// </summary>
        private bool IsFirewallRuleMatchedByNATRule(CheckPoint_Zone parentLayerRuleZone, CheckPoint_NAT_Rule natRule, CheckPoint_Rule fwRule, out CheckPointObject newFwRuleDest, out bool serviceMatchedToo)
        {
            newFwRuleDest = null;
            serviceMatchedToo = false;

            // If NAT rule interface is "any", it should match on EVERY firewall rule interface (zone)
            string natRuleInterface1 = (natRule.Interface1 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + natRule.Interface1) : parentLayerRuleZone.Name;
            string natRuleInterface2 = (natRule.Interface2 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + natRule.Interface2) : parentLayerRuleZone.Name;

            // Static NAT rule matching (no mirrors!!!)
            if (natRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
            {
                // Object-NAT rule matching
                if (natRule.IsObjectNatRule)
                {
                    if (natRuleInterface2 == parentLayerRuleZone.Name)
                    {
                        var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
                        var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

                        if (fwRuleDestRanges.Overlaps(natSourceRanges))
                        {
                            newFwRuleDest = natRule.TranslatedSource ?? _cpObjects.GetObject(CheckPointObject.Any);
                        }
                    }
                }
                else   // Manual-NAT or Twice-NAT rule matching
                {
                    var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
                    var natDestRanges = (natRule.Destination != null) ? GetRanges(natRule.Destination) : IPRanges.Any();
                    var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
                    var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

                    bool natSourceModified = (natRule.TranslatedSource != null);
                    bool natDestModified = (natRule.TranslatedDestination != null);   // Twice-NAT rule matching only!!!

                    if (natSourceModified && natDestModified)
                    {
                        var natTranslatedDestRanges = GetRanges(natRule.TranslatedDestination);

                        if (natRuleInterface2 == parentLayerRuleZone.Name)
                        {
                            if (fwRuleDestRanges.Overlaps(natSourceRanges) && fwRuleSourceRanges.Overlaps(natTranslatedDestRanges))
                            {
                                newFwRuleDest = natRule.TranslatedSource;
                            }
                        }

                        if (natRuleInterface1 == parentLayerRuleZone.Name)
                        {
                            var natTranslatedSourceRanges = GetRanges(natRule.TranslatedSource);

                            if (fwRuleDestRanges.Overlaps(natTranslatedDestRanges) && fwRuleSourceRanges.Overlaps(natTranslatedSourceRanges))
                            {
                                newFwRuleDest = natRule.Destination ?? _cpObjects.GetObject(CheckPointObject.Any);
                            }
                        }
                    }
                    else if (natSourceModified)
                    {
                        if (natRuleInterface2 == parentLayerRuleZone.Name)
                        {
                            if (fwRuleDestRanges.Overlaps(natSourceRanges) && fwRuleSourceRanges.Overlaps(natDestRanges))
                            {
                                newFwRuleDest = natRule.TranslatedSource;
                            }
                        }
                    }
                    else if (natDestModified)
                    {
                        if (natRuleInterface1 == parentLayerRuleZone.Name)
                        {
                            var natTranslatedDestRanges = GetRanges(natRule.TranslatedDestination);

                            if (fwRuleDestRanges.Overlaps(natTranslatedDestRanges) && fwRuleSourceRanges.Overlaps(natSourceRanges))
                            {
                                newFwRuleDest = natRule.Destination ?? _cpObjects.GetObject(CheckPointObject.Any);
                            }
                        }
                    }
                }
            }
            else   // Dynamic NAT rule matching (dynamic source and static dest)
            {
                bool natDestModified = (natRule.TranslatedDestination != null);   // Twice-NAT rule matching only!!!

                if (natDestModified)
                {
                    if (natRuleInterface1 == parentLayerRuleZone.Name)
                    {
                        var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
                        var natTranslatedDestRanges = GetRanges(natRule.TranslatedDestination);
                        var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
                        var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

                        if (fwRuleDestRanges.Overlaps(natTranslatedDestRanges) && fwRuleSourceRanges.Overlaps(natSourceRanges))
                        {
                            newFwRuleDest = natRule.TranslatedDestination;
                        }
                    }
                }
            }

            // Match on service too...
            if (newFwRuleDest != null)
            {
                if (natRule.Service == null)
                {
                    // No NAT service at all
                    return true;
                }

                if (fwRule.Service.Count == 0)
                {
                    // TODO: ???
                }
                else if (fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any)
                {
                    // There is only one service in FW rule and it is "any", no matter what NAT rule service is...
                    serviceMatchedToo = true;
                    return true;
                }
                else if (fwRule.Service.Any(fwService => natRule.Service.Name == fwService.Name ||
                         CheckPointServiceObjectsFactory.CheckServicesPortRangesOverlapping(natRule.Service, fwService)))
                {
                    // 1. service names match - NAT rule service appears in the list of FW rule's services
                    // 2. service port ranges match - NAT rule service should be a subset of FW rule's services
                    serviceMatchedToo = true;
                    return true;
                }
            }

            return false;
        }

        private IPRanges GetRanges(CheckPointObject cpObject)
        {
            if (cpObject == null || cpObject.Name == CheckPointObject.Any)
            {
                return new IPRanges(new IPRange(IPRange.Any));
            }

            if (cpObject.GetType().ToString().EndsWith("_NetworkGroup"))
            {
                return GetGroupRanges((CheckPoint_NetworkGroup)cpObject);
            }

            if (cpObject.GetType().ToString().EndsWith("_Zone"))
            {
                return GetZoneRanges((CheckPoint_Zone)cpObject);
            }

            if (cpObject.GetType().ToString().EndsWith("_Host"))
            {
                return ((CheckPoint_Host)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Network"))
            {
                return ((CheckPoint_Network)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Range"))
            {
                return ((CheckPoint_Range)cpObject).GetIPRanges();
            }

            return new IPRanges();
        }

        private IPRanges GetZoneRanges(CheckPoint_Zone cpZone)
        {
            // get Cisco interface object
            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);
            if (ciscoInterface != null && (ciscoInterface.LeadsToInternet || ciscoInterface.SecurityLevel == 0))
            {
                return new IPRanges(new IPRange(IPRange.Any));
            }

            string ifcSubnetsName = cpZone.Name + "_subnets";
            var ifcGroupObject = _cpObjects.GetObject(ifcSubnetsName);
            if (ifcGroupObject != null)
            {
                if (ifcGroupObject.GetType().ToString().EndsWith("_NetworkGroup"))
                {
                    var ifcSubnets = (CheckPoint_NetworkGroup)ifcGroupObject;
                    return GetGroupRanges(ifcSubnets);
                }

                if (ifcGroupObject.GetType().ToString().EndsWith("_GroupWithExclusion"))
                {
                    var groupWithExclusion = (CheckPoint_GroupWithExclusion)ifcGroupObject;
                    var groupInclude = (CheckPoint_NetworkGroup)_cpObjects.GetObject(groupWithExclusion.Include);
                    var groupExcept = (CheckPoint_NetworkGroup)_cpObjects.GetObject(groupWithExclusion.Except);
                    return GetGroupWithExclusionRanges(groupInclude, groupExcept);
                }
            }

            return new IPRanges();
        }

        private IPRanges GetGroupRanges(CheckPoint_NetworkGroup cpNetworkGroup)
        {
            var ranges = new IPRanges();

            foreach (string memberName in cpNetworkGroup.Members)
            {
                var cpObject = _cpObjects.GetObject(memberName);
                if (cpObject != null)
                {
                    if (cpObject.GetType().ToString().EndsWith("_NetworkGroup"))
                    {
                        ranges += GetGroupRanges((CheckPoint_NetworkGroup)cpObject);
                    }
                    else
                    {
                        ranges += cpObject.GetIPRanges();
                    }
                }
            }

            return ranges;
        }

        private IPRanges GetGroupWithExclusionRanges(CheckPoint_NetworkGroup includeGroup, CheckPoint_NetworkGroup excludeGroup)
        {
            IPRanges includeRanges = IPRanges.Merge(GetGroupRanges(includeGroup));
            IPRanges excludeRanges = IPRanges.Merge(GetGroupRanges(excludeGroup));

            var ranges = new IPRanges();

            foreach (IPRange range in includeRanges.Ranges)
            {
                ranges += IPRanges.Negate(range, excludeRanges);
            }

            return IPRanges.Merge(ranges);
        }

        private void Add_Optimized_Package()
        {
            CheckPoint_Package regularPackage = _cpPackages[0];

            var optimizedPackage = new CheckPoint_Package();
            optimizedPackage.Name = _policyPackageOptimizedName;
            optimizedPackage.ParentLayer.Name = optimizedPackage.NameOfAccessLayer;
            optimizedPackage.ConversionIncidentType = regularPackage.ConversionIncidentType;

            var regular2OptimizedLayers = new Dictionary<string, string>();

            foreach (CheckPoint_Layer layer in regularPackage.SubPolicies)
            {
                string optimizedSubPolicyName = layer.Name + "_opt";
                CheckPoint_Layer optimizedLayer = RuleBaseOptimizer.Optimize(layer, optimizedSubPolicyName);

                if (!regular2OptimizedLayers.ContainsKey(layer.Name))
                {
                    regular2OptimizedLayers.Add(layer.Name, optimizedSubPolicyName);
                    optimizedPackage.SubPolicies.Add(optimizedLayer);
                }
            }

            foreach (CheckPoint_Rule rule in regularPackage.ParentLayer.Rules)
            {
                CheckPoint_Rule newRule = rule.Clone();
                if (newRule.Action == CheckPoint_Rule.ActionType.SubPolicy)
                {
                    newRule.SubPolicyName = regular2OptimizedLayers[rule.SubPolicyName];
                }
                newRule.Layer = optimizedPackage.ParentLayer.Name;

                optimizedPackage.ParentLayer.Rules.Add(newRule);
            }

            AddCheckPointObject(optimizedPackage);
        }

        private void CreateObjectsScript(string toolVersion)
        {
            const int publishLatency = 100;

            using (var file = new StreamWriter(ObjectsScriptFile, false))
            {
                file.WriteLine(CLIScriptBuilder.GenerateScriptHeader(toolVersion, true));
                file.WriteLine(CLIScriptBuilder.GenerateRunCommandScript("failed_objects.txt"));
                file.WriteLine(CLIScriptBuilder.GenerateLoginScript(DomainName, "failed_objects.txt"));
                file.WriteLine(CLIScriptBuilder.GenerateDiagnosticsCommandScript("SmartMove_Create_Objects"));

                int totalObjectsCount = _cpDomains.Count +
                                        _cpHosts.Count +
                                        _cpNetworks.Count +
                                        _cpRanges.Count +
                                        _cpNetworkGroups.Count +
                                        _cpGroupsWithExclusion.Count +
                                        _cpZones.Count +
                                        _cpTcpServices.Count +
                                        _cpUdpServices.Count +
                                        _cpOtherServices.Count +
                                        _cpServiceGroups.Count +
                                        _cpTimeGroups.Count;

                if (_cpSimpleGateway != null)
                {
                    ++totalObjectsCount;
                }

                if (totalObjectsCount > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Creating total of {0} Objects...", totalObjectsCount)));
                }

                if (_cpDomains.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Domain", _cpDomains.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_Domain obj in _cpDomains)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpHosts.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Host", _cpHosts.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_Host obj in _cpHosts)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpNetworks.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Network", _cpNetworks.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_Network obj in _cpNetworks)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpRanges.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Address Range", _cpRanges.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_Range obj in _cpRanges)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                CheckPoint_NetworkGroup allInternal = null;

                if (_cpNetworkGroups.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Network Group", _cpNetworkGroups.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_NetworkGroup obj in _cpNetworkGroups)
                    {
                        if (obj.Name == AllInternalNetwotkGroupName)
                        {
                            allInternal = obj;
                            continue;
                        }

                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpGroupsWithExclusion.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Group with exclusion", _cpGroupsWithExclusion.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_GroupWithExclusion obj in _cpGroupsWithExclusion)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (allInternal != null)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateObjectScript(allInternal));
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpSimpleGateway != null)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateObjectScript(_cpSimpleGateway));
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpZones.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Zone", _cpZones.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_Zone obj in _cpZones)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpTcpServices.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "TCP Service", _cpTcpServices.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_TcpService obj in _cpTcpServices)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpUdpServices.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "UDP Service", _cpUdpServices.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_UdpService obj in _cpUdpServices)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpOtherServices.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Other Service", _cpOtherServices.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_OtherService obj in _cpOtherServices)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpServiceGroups.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Service Group", _cpServiceGroups.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_ServiceGroup obj in _cpServiceGroups)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                if (_cpTimeGroups.Count > 0)
                {
                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Create {0} Objects (x{1}) ", "Time Group", _cpTimeGroups.Count)));
                    int objectsCount = 0;
                    foreach (CheckPoint_TimeGroup obj in _cpTimeGroups)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(obj));

                        objectsCount++;
                        if (objectsCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                        }
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                }

                file.WriteLine(CLIScriptBuilder.GenerateScriptFooter("failed_objects.txt"));
            }
        }

        private void CreatePackagesScript(string toolVersion)
        {
            const int publishLatency = 100;
            int packageNumber = 0;

            foreach (CheckPoint_Package package in _cpPackages)
            {
                ++packageNumber;

                string filename = _targetFolder + "\\" + package.Name + ".sh";
                string errorsReportFile = (packageNumber == 1) ? "failed_package.txt" : "failed_package_opt.txt";
                string diagnosticsTarget = (packageNumber == 1) ? "SmartMove_Create_Policy" : "SmartMove_Create_Optimized_Policy";

                using (var file = new StreamWriter(filename, false))
                {
                    file.WriteLine(CLIScriptBuilder.GenerateScriptHeader(toolVersion, false));
                    file.WriteLine(CLIScriptBuilder.GenerateRunCommandScript(errorsReportFile));
                    file.WriteLine(CLIScriptBuilder.GenerateLoginScript(DomainName, errorsReportFile));
                    file.WriteLine(CLIScriptBuilder.GenerateDiagnosticsCommandScript(diagnosticsTarget));

                    file.WriteLine(CLIScriptBuilder.GenerateObjectScript(package));

                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Layers: Creating {0} sub-policies", package.SubPolicies.Count())));
                    foreach (CheckPoint_Layer layer in package.SubPolicies)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(layer));

                        file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Add rules to layer {0}", layer.Name)));
                        int rulesCount = 0;
                        foreach (CheckPoint_Rule rule in layer.Rules)
                        {
                            file.WriteLine(CLIScriptBuilder.GenerateObjectScript(rule));

                            rulesCount++;
                            if (rulesCount % publishLatency == 0)
                            {
                                file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                                file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Add rules to layer {0}", layer.Name)));
                            }
                            file.WriteLine(CLIScriptBuilder.GenerateRuleInstructionScript(string.Format("rule {0}/{1}", rulesCount, layer.Rules.Count)));
                        }
                        file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                    }
                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());

                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Add rules to parent layer {0}", package.NameOfAccessLayer)));
                    int parentRulesCount = 0;
                    foreach (CheckPoint_Rule parentRule in package.ParentLayer.Rules)
                    {
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(parentRule));

                        parentRulesCount++;
                        if (parentRulesCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                            file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Add rules to parent layer {0}", package.NameOfAccessLayer)));
                        }
                        file.WriteLine(CLIScriptBuilder.GenerateRuleInstructionScript(string.Format("rule {0}/{1}", parentRulesCount, package.ParentLayer.Rules.Count)));
                    }

                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());

                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Delete package redundant automatic cleanup rule")));
                    file.WriteLine(CLIScriptBuilder.GenerateGeneralCommandScript(package.CLIDeleteAutomaticCleanupRule()));

                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());

                    file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Add rules to NAT layer")));
                    int natRulesCount = 0;
                    foreach (CheckPoint_NAT_Rule rule in _cpNatRules)
                    {
                        rule.Package = package.Name;
                        file.WriteLine(CLIScriptBuilder.GenerateObjectScript(rule));

                        natRulesCount++;
                        if (natRulesCount % publishLatency == 0)
                        {
                            file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                            file.WriteLine(CLIScriptBuilder.GenerateInstructionScript(string.Format("Add rules to NAT layer")));
                        }
                        file.WriteLine(CLIScriptBuilder.GenerateRuleInstructionScript(string.Format("rule {0}/{1}", natRulesCount, _cpNatRules.Count)));
                    }

                    file.WriteLine(CLIScriptBuilder.GeneratePublishScript());
                    file.WriteLine(CLIScriptBuilder.GenerateScriptFooter(errorsReportFile));
                }
            }
        }

        private void CreateObjectsHtml()
        {
            using (var file = new StreamWriter(ObjectsHtmlFile, false))
            {
                file.WriteLine("<html>");
                file.WriteLine("<head>");
                file.WriteLine("<style>");
                file.WriteLine("  body { font-family: Arial; }");
                file.WriteLine("</style>");
                file.WriteLine("</head>");

                file.WriteLine("<body>");

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "Domains", _cpDomains.Count());
                foreach (CheckPoint_Domain obj in _cpDomains)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "Hosts", _cpHosts.Count());
                foreach (CheckPoint_Host obj in _cpHosts)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "Networks", _cpNetworks.Count());
                foreach (CheckPoint_Network obj in _cpNetworks)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "Network Groups", _cpNetworkGroups.Count());
                foreach (CheckPoint_NetworkGroup obj in _cpNetworkGroups)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "Groups with exclusion", _cpGroupsWithExclusion.Count());
                foreach (CheckPoint_GroupWithExclusion obj in _cpGroupsWithExclusion)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                if (_cpSimpleGateway != null)
                {
                    file.WriteLine("<h2> Simple Gateway Object (x1) </h2>");
                    file.WriteLine("<div id=\"" + _cpSimpleGateway.Name + "\">");
                    file.WriteLine(_cpSimpleGateway.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "Zones", _cpZones.Count());
                foreach (CheckPoint_Zone obj in _cpZones)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "TCP Services", _cpTcpServices.Count());
                foreach (CheckPoint_TcpService obj in _cpTcpServices)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "UDP Services", _cpUdpServices.Count());
                foreach (CheckPoint_UdpService obj in _cpUdpServices)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "Other Services", _cpOtherServices.Count());
                foreach (CheckPoint_OtherService obj in _cpOtherServices)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "Service Groups", _cpServiceGroups.Count());
                foreach (CheckPoint_ServiceGroup obj in _cpServiceGroups)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("<h2> {0} Objects (x{1}) </h2>", "Time Groups", _cpTimeGroups.Count());
                foreach (CheckPoint_TimeGroup obj in _cpTimeGroups)
                {
                    file.WriteLine("<div id=\"" + obj.Name + "\">");
                    file.WriteLine(obj.ToCLIScript());
                    file.WriteLine("</div>");
                }

                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        private string RuleItemsList2Html(List<CheckPointObject> ruleItems, bool isCellNegated, string defaultValue, ref ConversionIncidentType ruleConversionIncidentType)
        {
            if (ruleItems.Count == 0)
            {
                return defaultValue;
            }

            string res = "";

            if (isCellNegated)
            {
                res += "<div style='text-align: center';>";
                res += "<div style='color: white; background-color: #6e0c0c; font-style: italic; padding-left: 2px; padding-right: 2px; border-radius: 3px; display: inline-block;'>Negated</div>";
                res += "</div>";
            }

            foreach (CheckPointObject item in ruleItems)
            {
                if (_cpObjects.IsKnownService(item.Name))
                {
                    res += "<div>" + item.Name + "</div>";
                }
                else
                {
                    if (item.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        if (item.ConversionIncidentType > ruleConversionIncidentType)   // Error type overrides information type!!!
                        {
                            ruleConversionIncidentType = item.ConversionIncidentType;
                        }
                        res += "<div>" + BuildConversionIncidentLinkTag(item.ConvertedCommandId) + "<a href='./" + Path.GetFileName(ObjectsHtmlFile) + "#" + item.Name + "' target='_blank'>" + item.Name + "</a></div>";
                    }
                    else
                    {
                        res += "<div><a href='./" + Path.GetFileName(ObjectsHtmlFile) + "#" + item.Name + "' target='_blank'>" + item.Name + "</a></div>";
                    }
                }
            }

            return res;
        }

        private string BuildConversionIncidentInfo(int ciscoCommandId)
        {
            string conversionIncidentInfo = "";

            if (_conversionIncidentsByCiscoLineNumber.Any() && _conversionIncidentsByCiscoLineNumber.ContainsKey(ciscoCommandId))
            {
                var sb = new StringBuilder();
                bool isError = false;

                foreach (var conversionIncident in _conversionIncidentsByCiscoLineNumber[ciscoCommandId])
                {
                    if (sb.Length > 0)
                    {
                        sb.Append("\n\r");
                    }
                    sb.Append(conversionIncident.Title);
                    sb.Append(" [");
                    sb.Append(conversionIncident.Description);
                    sb.Append("]");

                    if (conversionIncident.IncidentType == ConversionIncidentType.ManualActionRequired)
                    {
                        isError = true;
                    }
                }

                conversionIncidentInfo = string.Format(isError ? HtmlErrorImageTagFormat : HtmlAlertImageTagFormat, sb.ToString());
            }

            return conversionIncidentInfo;
        }

        private string BuildConversionIncidentLinkTag(int ciscoCommandId)
        {
            return string.Format("<a href=\"./{0}#line_{1}\" target=\"_blank\">{2}</a>", Path.GetFileName(CiscoHtmlFile), ciscoCommandId, BuildConversionIncidentInfo(ciscoCommandId));
        }

        private string BuildInspectedRuleInfo(string ciscoClassMapName)
        {
            string inspectTooltip = "Rule traffic is affected by Cisco inspect policy. [class-map objects: " + ciscoClassMapName + "]";
            string htmlInspectedImageTag = string.Format(HtmlAlertImageTagFormat, inspectTooltip);
            return htmlInspectedImageTag;
        }

        private string BuildInspectedRuleLinkTag(string ciscoClassMapName)
        {
            foreach (var ciscoCommand in CiscoClassMapCommands)
            {
                var ciscoClassMapCommand = (Cisco_ClassMap)ciscoCommand;
                if (ciscoClassMapCommand.ClassMapName == ciscoClassMapName)
                {
                    return string.Format("<a href=\"./{0}#line_{1}\" target=\"_blank\">{2}</a>", Path.GetFileName(CiscoHtmlFile), ciscoClassMapCommand.Id, ciscoClassMapName);
                }
            }

            return ciscoClassMapName;
        }

        private string GenerateRulebaseHtmlReportDateTime()
        {
            var currentDate = DateTime.Now.ToLocalTime();
            var dtfi = new DateTimeFormatInfo { DateSeparator = "." };
            var currentDateString = currentDate.ToString("d", dtfi);
            var currentTimeString = currentDate.ToString("HH:mm", dtfi);
            var policyHtmlReportDateTime = currentDateString + " \\ " + currentTimeString;

            return policyHtmlReportDateTime;
        }

        #endregion

        #region Public Methods

        public void Convert(string toolVersion)
        {
            RaiseConversionProgress(20, "Converting obects ...");
            _cpObjects.Initialize();   // must be first!!!

            foreach (var cpObject in _cpObjects.GetPredefinedObjects())
            {
                _duplicateNamesLookup.Add(cpObject.Name, new DuplicateNameInfo(true));
            }

            PopulateCiscoNetworkObjects();
            CheckCiscoInterfacesTraffic();
            CheckCiscoInterfacesAntiSpoofing();
            Add_Networks();
            Add_Objects();
            Add_NetworkGroups();
            Add_Interfaces_and_Routes();
            Add_Zones();
            Add_or_Modify_Interface_Groups();
            Add_Services_and_ServiceGroups();
            RaiseConversionProgress(30, "Converting rules ...");
            Add_Package();

            if (ConvertNat)
            {
                RaiseConversionProgress(40, "Converting NAT rules ...");
                Add_object_NAT();
                Add_NAT_Rules();
                RaiseConversionProgress(50, "Creating NAT rulebase ...");
                CreateNATRulebase();
                RaiseConversionProgress(60, "Creating Firewall rulebase ...");
                MatchNATRulesIntoFirewallPolicy();
            }

            // This should be done here, after all objects are converted!!!
            EnforceObjectNameValidity();

            RaiseConversionProgress(70, "Optimizing Firewall rulebase ...");
            Add_Optimized_Package();
            RaiseConversionProgress(80, "Generating CLI scripts ...");
            CreateObjectsScript(toolVersion);
            CreatePackagesScript(toolVersion);
            CreateObjectsHtml();

            // This data container is important, and is used during rulebases html reports generation for incidents lookup!!!
            var incidentsGroupedByLineNumber = _conversionIncidents.GroupBy(error => error.LineNumber);
            _conversionIncidentsByCiscoLineNumber = incidentsGroupedByLineNumber.ToDictionary(error => error.Key, error => error.Distinct().ToList());

            // Resolve the conversion categories/lines count to report to the user.
            ConversionIncidentCategoriesCount = _conversionIncidents.GroupBy(error => error.Title).Count();
            ConversionIncidentsCommandsCount = incidentsGroupedByLineNumber.Count();
        }

        public int RulesInConvertedPackage()
        {
            return _cpPackages[0].TotalRules();
        }

        public int RulesInConvertedOptimizedPackage()
        {
            return _cpPackages[1].TotalRules();
        }

        public int RulesInNatLayer()
        {
            return _cpNatRules.Count;
        }

        public void ExportCiscoConfigurationAsHtml()
        {
            using (var file = new StreamWriter(CiscoHtmlFile))
            {
                file.WriteLine("<html>");
                file.WriteLine("<head>");
                file.WriteLine("<style>");
                file.WriteLine("  body { font-family: Arial; }");
                file.WriteLine("  .report_table { border-collapse: separate;border-spacing: 0px; font-family: Lucida Console;}");
                file.WriteLine("  td {padding: 5px; vertical-align: top}");
                file.WriteLine("  .line_number {background: lightgray;}");
                file.WriteLine("  .unhandeled {color: Fuchsia;}");
                file.WriteLine("  .notimportant {color: Gray;}");
                file.WriteLine("  .converterr {color: Red;}");
                file.WriteLine("  .convertinfo {color: Blue;}");
                file.WriteLine("  .err_title {color: Red;}");
                file.WriteLine("  .info_title {color: Blue;}");
                file.WriteLine("</style>");
                file.WriteLine("</head>");

                file.WriteLine("<body>");
                file.WriteLine("<h2>Cisco config file</h2>");

                file.WriteLine("<table style='margin-bottom: 20px; background: rgb(250,250,250);'>");
                file.WriteLine("   <tr><td style='font-size: 14px; text-decoration: underline;'>Colors Legend</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Black;'>Parsed commands</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Gray;'>Skipped commands</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Fuchsia;'>Unknown commands</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Red;'>Commands with conversion error</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Blue;'>Commands with conversion notification</td></tr>");
                file.WriteLine("</table>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<div style='margin-bottom: 20px;'>");
                    file.WriteLine("   <span style='vertical-align: middle; font-size: 14px;'>" + HtmlAlertImageTag);
                    file.WriteLine("      <a href='#ConversionIncidents'>Found " + ConversionIncidentCategoriesCount + " conversion issues in " + ConversionIncidentsCommandsCount + " configuration lines</a>");
                    file.WriteLine("   </span>");
                    file.WriteLine("</div>");
                }

                file.WriteLine("<table class=\"report_table\">");

                foreach (CiscoCommand command in CiscoAllCommands)
                {
                    string lineStyle = "";
                    string indentation = "";

                    if (!command.KnownCommand) lineStyle = " class=\"unhandeled\" ";
                    if (command.NotAnInterestingCommand) lineStyle = " class=\"notimportant\" ";
                    if (command.ConversionIncidentType == ConversionIncidentType.ManualActionRequired) lineStyle = " class=\"converterr\" ";
                    if (command.ConversionIncidentType == ConversionIncidentType.Informative) lineStyle = " class=\"convertinfo\" ";

                    for (int i = 0; i < command.IndentationLevel; i++)
                    {
                        indentation += "&nbsp;&nbsp;";
                    }

                    string incidentFlag = "";
                    if (command.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        incidentFlag = BuildConversionIncidentInfo(command.Id);
                    }

                    file.WriteLine("<tr>");
                    file.WriteLine("  <td id=\"line_" + command.Id + "\" class=\"line_number\" style=\"text-align: right;\">" + incidentFlag + command.Id + "</td>" + "<td " + lineStyle + " >" + indentation + command.Text + "</td>");
                    file.WriteLine("</tr>");
                }
                file.WriteLine("</table>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<hr/>");
                    file.WriteLine("<h2 id=\"ConversionIncidents\">Conversion Issues</h2>");

                    bool first = true;
                    string prevTitle = "";

                    foreach (ConversionIncident err in _conversionIncidents.OrderByDescending(item => item.IncidentType).ThenBy(item => item.Title).ThenBy(item => item.LineNumber).ToList())
                    {
                        if (first)
                        {
                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        if (!first && prevTitle != err.Title)
                        {
                            file.WriteLine("</table>");

                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        file.WriteLine("  <tr>");
                        file.WriteLine("    <td class=\"line_number\" style=\"text-align: right;\"> <a href=\"#line_" + err.LineNumber + "\">" + err.LineNumber + "</a></td>");
                        file.WriteLine("    <td>" + err.Description + "</td>");
                        file.WriteLine("  </tr>");

                        first = false;
                        prevTitle = err.Title;
                    }
                }

                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        public void ExportPolicyPackagesAsHtml(string toolVersion)
        {
            foreach (CheckPoint_Package package in _cpPackages)
            {
                string filename = _targetFolder + "\\" + package.Name + ".html";

                using (var file = new StreamWriter(filename, false))
                {
                    var rulesWithConversionErrors = new Dictionary<string, CheckPoint_Rule>();
                    var rulesWithConversionInfos = new Dictionary<string, CheckPoint_Rule>();
                    var rulesWithInspection = new Dictionary<string, List<CheckPoint_Rule>>();

                    file.WriteLine("<html>");
                    file.WriteLine("<head>");
                    file.WriteLine("<style>");
                    file.WriteLine("  body { font-family: Helvetica; margin-left: 0px; margin-right: 0px; margin-top: 0px; }");
                    file.WriteLine("  table { border-collapse: collapse; border: 1px solid gray; margin: 20px; }");
                    file.WriteLine("  td { vertical-align: text-top; padding: 6px; border: 1px solid gray; }");
                    file.WriteLine("  th { vertical-align: text-top; padding: 6px; border: 1px solid gray; background-color: rgb(87,99,114); font-weight: bold; color: white; }");
                    file.WriteLine("  .report_time { font-family: Segoe UI; font-size: 14px; font-weight: normal; border-left: 1px solid #c9c9c9; padding: 10px; } ");
                    file.WriteLine("  .rule_number { background-color: rgb(245,245,245); text-align: right; } ");
                    file.WriteLine("  .parent_rule { font-weight: bold; }");
                    file.WriteLine("  .parent_rule_disabled { font-weight: bold; text-decoration: line-through; }");
                    file.WriteLine("  .disabled_rule { text-decoration: line-through; } ");
                    file.WriteLine("  .errors_header { background-color: rgb(213,51,30); } ");
                    file.WriteLine("  .accept { color: green; }");
                    file.WriteLine("  .drop { color: red; }");
                    file.WriteLine("  .comments { font-family: Lucida Console; }");
                    file.WriteLine("</style>");
                    file.WriteLine("<script>");
                    file.WriteLine("   var errorsCounter = 0;");
                    file.WriteLine("   var infosCounter = 0;");
                    file.WriteLine("   function displayIncidentsCount() {");
                    file.WriteLine("      if (errorsCounter > 0) {");
                    file.WriteLine("         var elem1 = document.getElementById('errorsCountHost');");
                    file.WriteLine("         if (elem1 != null) {");
                    file.WriteLine("            elem1.style.display = 'inline';");
                    file.WriteLine("         }");
                    file.WriteLine("         var elem2 = document.getElementById('errorsCount');");
                    file.WriteLine("         if (elem2 != null) {");
                    file.WriteLine("            elem2.innerText = elem2.innerText + errorsCounter;");
                    file.WriteLine("         }");
                    file.WriteLine("      }");
                    file.WriteLine("      if (infosCounter > 0) {");
                    file.WriteLine("         var elem1 = document.getElementById('infosCountHost');");
                    file.WriteLine("         if (elem1 != null) {");
                    file.WriteLine("            elem1.style.display = 'inline';");
                    file.WriteLine("         }");
                    file.WriteLine("         var elem2 = document.getElementById('infosCount');");
                    file.WriteLine("         if (elem2 != null) {");
                    file.WriteLine("            elem2.innerText = elem2.innerText + infosCounter;");
                    file.WriteLine("         }");
                    file.WriteLine("      }");
                    file.WriteLine("   }");
                    file.WriteLine("</script>");
                    file.WriteLine("</head>");
                    file.WriteLine("<body onLoad='displayIncidentsCount()'>");

                    // Generate the report header
                    file.WriteLine("<div style='height: 70px; line-height: 70px; background-color: black; padding-left: 20px; margin-bottom: 35px; color: white; font-family: Segoe UI; font-size: 20px;'>");
                    file.WriteLine("   <img style='width: 33px; height: 32px; padding-top: 20;' " + HtmlToolLogoImageSource + "/>");
                    file.WriteLine("   <span style='font-weight: bold; vertical-align: top;'>SmartMove</span>");
                    file.WriteLine("   <span style='font-size: 10px; position: absolute; padding-top: 4px; margin-left: 10px;'>ver " + toolVersion + "</span>");
                    file.WriteLine("   <img style='width: 118px; height: 20px; position: absolute; right: 20; padding-top: 25;' " + HtmlCPLogoImageSource + "/>");
                    file.WriteLine("</div>");
                    file.WriteLine("<div style='font-size: 30px; font-weight: lighter; margin-left: 20px; margin-bottom: 30px;'>CONVERSION REPORT  ");
                    file.WriteLine("   <span id='reportTime' class='report_time'>" + GenerateRulebaseHtmlReportDateTime() + "</span>");
                    file.WriteLine("</div>");
                    file.WriteLine("<div style='font-size: 16px; margin-left: 20px; margin-bottom: 15px;'>");
                    file.WriteLine("   <span style='font-weight: normal;'>Policy Package: </span><span style='font-weight: bold;'>" + package.Name + "</span>");
                    file.WriteLine("</div>");

                    if (package.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        file.WriteLine("<div style='margin-left: 20px;'>");
                        file.WriteLine("   <span style='font-weight: bold;'>Found Conversion Issues:</span>");
                        file.WriteLine("   <span id='errorsCountHost' style='display: none; margin-left: 10px; vertical-align: middle;'>" + string.Format(HtmlErrorImageTagFormat, "Conversion Errors"));
                        file.WriteLine("      <a id='errorsCount' href='#PolicyConversionErrors' style='margin-left: 2px; vertical-align: top;'></a>");
                        file.WriteLine("   </span>");
                        file.WriteLine("   <span id='infosCountHost' style='display: none; margin-left: 10px; vertical-align: middle;'>" + string.Format(HtmlAlertImageTagFormat, "Conversion Notifications"));
                        file.WriteLine("      <a id='infosCount' href='#PolicyConversionInfos' style='margin-left: 2px; vertical-align: top;'/></a>");
                        file.WriteLine("   </span>");
                        file.WriteLine("</div>");
                    }

                    // Generate the report body
                    file.WriteLine("<table>");
                    file.WriteLine("   <tr>");
                    file.WriteLine("      <th>No.</th> <th>Name</th> <th>Source</th> <th>Destination</th> <th>Service</th> <th>Action</th> <th>Time</th> <th>Track</th> <th>Comments</th> <th>Conversion Comments</th>");
                    file.WriteLine("   </tr>");

                    int ruleNumber = 1;

                    foreach (CheckPoint_Rule rule in package.ParentLayer.Rules)
                    {
                        string action = "";
                        string actionStyle = "";
                        var dummy = ConversionIncidentType.None;

                        switch (rule.Action)
                        {
                            case CheckPoint_Rule.ActionType.Accept:
                            case CheckPoint_Rule.ActionType.Drop:
                                action = rule.Action.ToString();
                                actionStyle = rule.Action.ToString().ToLower();
                                break;

                            case CheckPoint_Rule.ActionType.SubPolicy:
                                action = "Sub-policy: " + rule.SubPolicyName;
                                actionStyle = "";
                                break;
                        }

                        if (rule.Enabled)
                        {
                            file.WriteLine("  <tr class='parent_rule'>");
                            file.WriteLine("      <td class='rule_number'>" + ruleNumber + "</td>");
                        }
                        else
                        {
                            file.WriteLine("  <tr class='parent_rule_disabled'>");
                            file.WriteLine("      <td class='rule_number'>" + HtmlDisabledImageTag + ruleNumber + "</td>");
                        }
                        file.WriteLine("      <td>" + rule.Name + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(rule.Source, rule.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(rule.Destination, rule.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(rule.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td class='" + actionStyle + "'>" + action + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(rule.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + rule.Track.ToString() + "</td>");
                        file.WriteLine("      <td>" + rule.Comments + "</td>");
                        file.WriteLine("      <td>" + rule.ConversionComments + "</td>");
                        file.WriteLine("  </tr>");

                        if (rule.Action == CheckPoint_Rule.ActionType.SubPolicy)
                        {
                            foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                            {
                                int subRuleNumber = 1;

                                foreach (CheckPoint_Rule subRule in subPolicy.Rules)
                                {
                                    if (subRule.Layer == rule.SubPolicyName)
                                    {
                                        var ruleConversionIncidentType = ConversionIncidentType.None;
                                        bool isInspectedRule = !string.IsNullOrEmpty(subRule.Tag);
                                        string curRuleNumber = ruleNumber + "." + subRuleNumber;

                                        if (subRule.Enabled)
                                        {
                                            file.WriteLine("  <tr id=\"" + curRuleNumber + "\">");
                                        }
                                        else
                                        {
                                            file.WriteLine("  <tr class='disabled_rule' id=\"" + curRuleNumber + "\">");
                                        }

                                        var sbCurRuleNumberColumnTag = new StringBuilder();
                                        sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                        if (isInspectedRule)
                                        {
                                            sbCurRuleNumberColumnTag.Append(BuildInspectedRuleInfo(subRule.Tag));
                                        }
                                        if (subRule.ConversionIncidentType != ConversionIncidentType.None)
                                        {
                                            sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(subRule.ConvertedCommandId));
                                            ruleConversionIncidentType = subRule.ConversionIncidentType;
                                        }
                                        if (!subRule.Enabled)
                                        {
                                            sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                        }
                                        sbCurRuleNumberColumnTag.Append(curRuleNumber);
                                        sbCurRuleNumberColumnTag.Append("</td>");
                                        file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                                        file.WriteLine("      <td>" + subRule.Name + "</td>");
                                        file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Source, subRule.SourceNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                        file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Destination, subRule.DestinationNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                        file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Service, false, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                        file.WriteLine("      <td class='" + subRule.Action.ToString().ToLower() + "'>" + subRule.Action.ToString() + "</td>");
                                        file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Time, false, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                        file.WriteLine("      <td>" + subRule.Track.ToString() + "</td>");
                                        file.WriteLine("      <td class='comments'>" + subRule.Comments + "</td>");
                                        file.WriteLine("      <td class='comments'>" + subRule.ConversionComments + "</td>");
                                        file.WriteLine("  </tr>");

                                        subRuleNumber++;

                                        if (package.ConversionIncidentType != ConversionIncidentType.None && ruleConversionIncidentType != ConversionIncidentType.None)
                                        {
                                            if (ruleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                                            {
                                                rulesWithConversionErrors.Add(curRuleNumber, subRule);
                                            }
                                            else
                                            {
                                                rulesWithConversionInfos.Add(curRuleNumber, subRule);
                                            }
                                        }

                                        if (isInspectedRule)
                                        {
                                            string[] ciscoClassMapNames = subRule.Tag.Split(',');   // there may be several class-maps matching the same fw rule...
                                            subRule.Tag = curRuleNumber;   // replace class-map name (it is now the key of this dic) by curRuleNumber...

                                            foreach (var classMapName in ciscoClassMapNames)
                                            {
                                                if (!rulesWithInspection.ContainsKey(classMapName))
                                                {
                                                    var inspectedRules = new List<CheckPoint_Rule>();
                                                    rulesWithInspection.Add(classMapName, inspectedRules);
                                                }
                                                rulesWithInspection[classMapName].Add(subRule);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        ruleNumber++;
                    }

                    file.WriteLine("</table>");

                    if (rulesWithConversionErrors.Count > 0 || rulesWithConversionInfos.Count > 0 || rulesWithInspection.Count > 0)
                    {
                        file.WriteLine("<div id=\"PolicyConversionIncidents\" style='margin-left: 20px;'><h2>Policy Conversion Issues</h2></div>");
                    }

                    // Generate the errors report
                    if (rulesWithConversionErrors.Count > 0)
                    {
                        file.WriteLine("<script>");
                        file.WriteLine("   errorsCounter = " + rulesWithConversionErrors.Count + ";");
                        file.WriteLine("</script>");

                        file.WriteLine("<div id=\"PolicyConversionErrors\" style='margin-left: 20px;'><h3>Conversion Errors</h3></div>");
                        file.WriteLine("<table style='background-color: rgb(255,255,150);'>");
                        file.WriteLine("   <tr>");
                        file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Time</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                        file.WriteLine("   </tr>");

                        foreach (var ruleEntry in rulesWithConversionErrors)
                        {
                            var dummy = ConversionIncidentType.None;

                            if (ruleEntry.Value.Enabled)
                            {
                                file.WriteLine("  <tr>");
                            }
                            else
                            {
                                file.WriteLine("  <tr class='disabled_rule'>");
                            }

                            var sbCurRuleNumberColumnTag = new StringBuilder();
                            sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                            if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                            }
                            if (!ruleEntry.Value.Enabled)
                            {
                                sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                            }
                            sbCurRuleNumberColumnTag.Append("<a href=\"#");
                            sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                            sbCurRuleNumberColumnTag.Append("\">");
                            sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                            sbCurRuleNumberColumnTag.Append("</a></td>");
                            file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                            file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                            file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                            file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                            file.WriteLine("  </tr>");
                        }

                        file.WriteLine("</table>");
                    }

                    if (rulesWithConversionInfos.Count > 0 || rulesWithInspection.Count > 0)
                    {
                        int counter = (rulesWithInspection.Count > 0) ? 1 : 0;
                        counter += rulesWithConversionInfos.Count;

                        file.WriteLine("<script>");
                        file.WriteLine("   infosCounter = " + counter + ";");
                        file.WriteLine("</script>");
                        file.WriteLine("<div id=\"PolicyConversionInfos\" style='margin-left: 20px;'><h3>Conversion Notifications</h3></div>");
                    }

                    // Generate the information report
                    if (rulesWithConversionInfos.Count > 0)
                    {
                        file.WriteLine("<table style='background-color: rgb(220,240,247);'>");
                        file.WriteLine("   <tr>");
                        file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Time</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                        file.WriteLine("   </tr>");

                        foreach (var ruleEntry in rulesWithConversionInfos)
                        {
                            var dummy = ConversionIncidentType.None;

                            if (ruleEntry.Value.Enabled)
                            {
                                file.WriteLine("  <tr>");
                            }
                            else
                            {
                                file.WriteLine("  <tr class='disabled_rule'>");
                            }

                            var sbCurRuleNumberColumnTag = new StringBuilder();
                            sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                            if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                            }
                            if (!ruleEntry.Value.Enabled)
                            {
                                sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                            }
                            sbCurRuleNumberColumnTag.Append("<a href=\"#");
                            sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                            sbCurRuleNumberColumnTag.Append("\">");
                            sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                            sbCurRuleNumberColumnTag.Append("</a></td>");
                            file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                            file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                            file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                            file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                            file.WriteLine("  </tr>");
                        }

                        file.WriteLine("</table>");
                    }

                    // Generate the inspected rules report
                    if (rulesWithInspection.Count > 0)
                    {
                        file.WriteLine("<div style='margin-left: 20px;'><h3>Inspected Rules</h3></div>");
                        file.WriteLine("<div style='margin-left: 20px; margin-bottom: 20px;'>");
                        file.WriteLine("   <span style='vertical-align: middle;'>" + HtmlAlertImageTagFormat + "</span>");
                        file.WriteLine("   <span> The following firewall rules are matched by ");
                        file.WriteLine("      <a href='http://www.cisco.com/c/en/us/td/docs/security/asa/asa84/configuration/guide/asa_84_cli_config/mpf_inspect_maps.html' target='_blank'>Cisco Inspect classes</a>.");
                        file.WriteLine(" Please review for further possible modifications to rules after migration.</span>");
                        file.WriteLine("</div>");

                        foreach (var inspectionInfo in rulesWithInspection)
                        {
                            file.WriteLine("<div style='font-size: 14px; margin-left: 20px; margin-bottom: 15px;'>");
                            file.WriteLine("   <span>Cisco Inspect class-map: </span><span>" + BuildInspectedRuleLinkTag(inspectionInfo.Key) + "</span>");
                            file.WriteLine("</div>");

                            file.WriteLine("<table style='background-color: rgb(220,240,247);'>");
                            file.WriteLine("   <tr>");
                            file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Time</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                            file.WriteLine("   </tr>");

                            foreach (var ruleEntry in inspectionInfo.Value)
                            {
                                var dummy = ConversionIncidentType.None;

                                if (ruleEntry.Enabled)
                                {
                                    file.WriteLine("  <tr>");
                                }
                                else
                                {
                                    file.WriteLine("  <tr class='disabled_rule'>");
                                }

                                var sbRuleNumberColumnTag = new StringBuilder();
                                sbRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                if (ruleEntry.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    sbRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.ConvertedCommandId));
                                }
                                if (!ruleEntry.Enabled)
                                {
                                    sbRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                }
                                sbRuleNumberColumnTag.Append("<a href=\"#");
                                sbRuleNumberColumnTag.Append(ruleEntry.Tag);
                                sbRuleNumberColumnTag.Append("\">");
                                sbRuleNumberColumnTag.Append(ruleEntry.Tag);
                                sbRuleNumberColumnTag.Append("</a></td>");
                                file.WriteLine(sbRuleNumberColumnTag.ToString());

                                file.WriteLine("      <td>" + ruleEntry.Name + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Source, ruleEntry.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Destination, ruleEntry.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td class='" + ruleEntry.Action.ToString().ToLower() + "'>" + ruleEntry.Action.ToString() + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + ruleEntry.Track.ToString() + "</td>");
                                file.WriteLine("      <td class='comments'>" + ruleEntry.Comments + "</td>");
                                file.WriteLine("      <td class='comments'>" + ruleEntry.ConversionComments + "</td>");
                                file.WriteLine("  </tr>");
                            }

                            file.WriteLine("</table>");
                        }
                    }

                    file.WriteLine("</body>");
                    file.WriteLine("</html>");
                }
            }
        }

        public void ExportNATLayerAsHtml(string toolVersion)
        {
            using (var file = new StreamWriter(NatHtmlFile, false))
            {
                var rulesWithConversionErrors = new List<string>();
                var rulesWithConversionInfos = new List<string>();
                int errorsCount = 0;
                int infosCount = 0;

                file.WriteLine("<html>");
                file.WriteLine("<head>");
                file.WriteLine("<style>");
                file.WriteLine("  body { font-family: Helvetica; margin-left: 0px; margin-right: 0px; margin-top: 0px; }");
                file.WriteLine("  table { border-collapse: collapse; border: 1px solid gray; margin: 20px; }");
                file.WriteLine("  td { vertical-align: text-top; padding: 6px; border: 1px solid gray; }");
                file.WriteLine("  th { vertical-align: text-top; padding: 6px; border: 1px solid gray; background-color: rgb(87,99,114); font-weight: bold; color: white; }");
                file.WriteLine("  .report_time { font-family: Segoe UI; font-size: 14px; font-weight: normal; border-left: 1px solid #c9c9c9; padding: 10px; } ");
                file.WriteLine("  .rule_number { background-color: rgb(245,245,245); text-align: right; } ");
                file.WriteLine("  .errors_header { background-color: rgb(213,51,30); } ");
                file.WriteLine("  .disabled_rule { text-decoration: line-through; } ");
                file.WriteLine("  .comments { font-family: Lucida Console; }");
                file.WriteLine("</style>");
                file.WriteLine("<script>");
                file.WriteLine("   var errorsCounter = 0;");
                file.WriteLine("   var infosCounter = 0;");
                file.WriteLine("   function displayIncidentsCount() {");
                file.WriteLine("      if (errorsCounter > 0) {");
                file.WriteLine("         var elem1 = document.getElementById('errorsCountHost');");
                file.WriteLine("         if (elem1 != null) {");
                file.WriteLine("            elem1.style.display = 'inline';");
                file.WriteLine("         }");
                file.WriteLine("         var elem2 = document.getElementById('errorsCount');");
                file.WriteLine("         if (elem2 != null) {");
                file.WriteLine("            elem2.innerText = elem2.innerText + errorsCounter;");
                file.WriteLine("         }");
                file.WriteLine("      }");
                file.WriteLine("      if (infosCounter > 0) {");
                file.WriteLine("         var elem1 = document.getElementById('infosCountHost');");
                file.WriteLine("         if (elem1 != null) {");
                file.WriteLine("            elem1.style.display = 'inline';");
                file.WriteLine("         }");
                file.WriteLine("         var elem2 = document.getElementById('infosCount');");
                file.WriteLine("         if (elem2 != null) {");
                file.WriteLine("            elem2.innerText = elem2.innerText + infosCounter;");
                file.WriteLine("         }");
                file.WriteLine("      }");
                file.WriteLine("   }");
                file.WriteLine("</script>");
                file.WriteLine("</head>");
                file.WriteLine("<body onLoad='displayIncidentsCount()'>");

                // Generate the report header
                file.WriteLine("<div style='height: 70px; line-height: 70px; background-color: black; padding-left: 20px; margin-bottom: 35px; color: white; font-family: Segoe UI; font-size: 20px;'>");
                file.WriteLine("   <img style='width: 33px; height: 32px; padding-top: 20;' " + HtmlToolLogoImageSource + "/>");
                file.WriteLine("   <span style='font-weight: bold; vertical-align: top;'>SmartMove</span>");
                file.WriteLine("   <span style='font-size: 10px; position: absolute; padding-top: 4px; margin-left: 10px;'>ver " + toolVersion + "</span>");
                file.WriteLine("   <img style='width: 118px; height: 20px; position: absolute; right: 20; padding-top: 25;' " + HtmlCPLogoImageSource + "/>");
                file.WriteLine("</div>");
                file.WriteLine("<div style='font-size: 30px; font-weight: lighter; margin-left: 20px; margin-bottom: 30px;'>CONVERSION REPORT  ");
                file.WriteLine("   <span id='reportTime' class='report_time'>" + GenerateRulebaseHtmlReportDateTime() + "</span>");
                file.WriteLine("</div>");
                file.WriteLine("<div style='font-size: 16px; margin-left: 20px; margin-bottom: 15px;'>");
                file.WriteLine("   <span style='font-weight: normal;'>NAT Layer</span>");
                file.WriteLine("</div>");

                if (_hasNATConversionIncident)
                {
                    file.WriteLine("<div style='margin-left: 20px;'>");
                    file.WriteLine("   <span style='font-weight: bold;'>Found Conversion Issues:</span>");
                    file.WriteLine("   <span id='errorsCountHost' style='display: none; margin-left: 10px; vertical-align: middle;'>" + string.Format(HtmlErrorImageTagFormat, "Conversion Errors"));
                    file.WriteLine("      <a id='errorsCount' href='#PolicyConversionErrors' style='margin-left: 2px; vertical-align: top;'></a>");
                    file.WriteLine("   </span>");
                    file.WriteLine("   <span id='infosCountHost' style='display: none; margin-left: 10px; vertical-align: middle;'>" + string.Format(HtmlAlertImageTagFormat, "Conversion Notifications"));
                    file.WriteLine("      <a id='infosCount' href='#PolicyConversionInfos' style='margin-left: 2px; vertical-align: top;'/></a>");
                    file.WriteLine("   </span>");
                    file.WriteLine("</div>");
                }

                // Generate the report body
                file.WriteLine("<table>");
                file.WriteLine("   <tr>");
                file.WriteLine("      <th>No.</th> <th>Source</th> <th>Destination</th> <th>Service</th> <th>Translated-Source</th> <th>Translated-Destination</th> <th>Translated-Service</th> <th>Comments</th>");
                file.WriteLine("   </tr>");

                int ruleNumber = 1;

                foreach (CheckPoint_NAT_Rule rule in _cpNatRules)
                {
                    string source = (rule.Source == null) ? CheckPointObject.Any : rule.Source.Name;
                    string dest = (rule.Destination == null) ? CheckPointObject.Any : rule.Destination.Name;
                    string service = (rule.Service == null) ? CheckPointObject.Any : rule.Service.Name;
                    string xsource = (rule.TranslatedSource == null) ? "=orig" : rule.TranslatedSource.Name;
                    string xdest = (rule.TranslatedDestination == null) ? "=orig" : rule.TranslatedDestination.Name;
                    string xservice = (rule.TranslatedService == null) ? "=orig" : rule.TranslatedService.Name;

                    if (xsource != "=orig")
                    {
                        xsource = ((rule.Method == CheckPoint_NAT_Rule.NatMethod.Static) ? "static: " : "hide: ") + xsource;
                    }
                    if (xdest != "=orig")
                    {
                        xdest = "static: " + xdest;
                    }

                    string curRuleHtmlPart;
                    var curRuleHtmlFull = new List<string>();
                    var ruleConversionIncidentType = ConversionIncidentType.None;

                    if (rule.Enabled)
                    {
                        curRuleHtmlPart = "  <tr id=\"" + ruleNumber + "\">";
                    }
                    else
                    {
                        curRuleHtmlPart = "  <tr class='disabled_rule' id=\"" + ruleNumber + "\">";
                    }
                    file.WriteLine(curRuleHtmlPart);
                    curRuleHtmlFull.Add(curRuleHtmlPart);

                    var sbRuleNumberColumnTag = new StringBuilder();
                    var sbRuleNumberColumnWithLinkBackTag = new StringBuilder();
                    sbRuleNumberColumnTag.Append("      <td class='rule_number'>");
                    if (rule.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        sbRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(rule.ConvertedCommandId));
                        ruleConversionIncidentType = rule.ConversionIncidentType;
                    }
                    if (!rule.Enabled)
                    {
                        sbRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                    }
                    sbRuleNumberColumnWithLinkBackTag.Append(sbRuleNumberColumnTag);   // save this XML portion to be continued bellow
                    sbRuleNumberColumnTag.Append(ruleNumber);
                    sbRuleNumberColumnTag.Append("</td>");
                    curRuleHtmlPart = sbRuleNumberColumnTag.ToString();
                    file.WriteLine(curRuleHtmlPart);

                    sbRuleNumberColumnWithLinkBackTag.Append("<a href=\"#");
                    sbRuleNumberColumnWithLinkBackTag.Append(ruleNumber);
                    sbRuleNumberColumnWithLinkBackTag.Append("\">");
                    sbRuleNumberColumnWithLinkBackTag.Append(ruleNumber);
                    sbRuleNumberColumnWithLinkBackTag.Append("</a></td>");
                    curRuleHtmlFull.Add(sbRuleNumberColumnWithLinkBackTag.ToString());

                    if (rule.Source != null && rule.Source.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        curRuleHtmlPart = "      <td>" + BuildConversionIncidentLinkTag(rule.Source.ConvertedCommandId) + source + "</td>";
                        if (rule.Source.ConversionIncidentType > ruleConversionIncidentType)
                        {
                            ruleConversionIncidentType = rule.Source.ConversionIncidentType;
                        }
                    }
                    else
                    {
                        curRuleHtmlPart = "      <td>" + source + "</td>";
                    }
                    file.WriteLine(curRuleHtmlPart);
                    curRuleHtmlFull.Add(curRuleHtmlPart);

                    if (rule.Destination != null && rule.Destination.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        curRuleHtmlPart = "      <td>" + BuildConversionIncidentLinkTag(rule.Destination.ConvertedCommandId) + dest + "</td>";
                        if (rule.Destination.ConversionIncidentType > ruleConversionIncidentType)
                        {
                            ruleConversionIncidentType = rule.Destination.ConversionIncidentType;
                        }
                    }
                    else
                    {
                        curRuleHtmlPart = "      <td>" + dest + "</td>";
                    }
                    file.WriteLine(curRuleHtmlPart);
                    curRuleHtmlFull.Add(curRuleHtmlPart);

                    if (rule.Service != null && rule.Service.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        curRuleHtmlPart = "      <td>" + BuildConversionIncidentLinkTag(rule.Service.ConvertedCommandId) + service + "</td>";
                        if (rule.Service.ConversionIncidentType > ruleConversionIncidentType)
                        {
                            ruleConversionIncidentType = rule.Service.ConversionIncidentType;
                        }
                    }
                    else
                    {
                        curRuleHtmlPart = "      <td>" + service + "</td>";
                    }
                    file.WriteLine(curRuleHtmlPart);
                    curRuleHtmlFull.Add(curRuleHtmlPart);

                    if (rule.TranslatedSource != null && rule.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        curRuleHtmlPart = "      <td>" + BuildConversionIncidentLinkTag(rule.TranslatedSource.ConvertedCommandId) + xsource + "</td>";
                        if (rule.TranslatedSource.ConversionIncidentType > ruleConversionIncidentType)
                        {
                            ruleConversionIncidentType = rule.TranslatedSource.ConversionIncidentType;
                        }
                    }
                    else
                    {
                        curRuleHtmlPart = "      <td>" + xsource + "</td>";
                    }
                    file.WriteLine(curRuleHtmlPart);
                    curRuleHtmlFull.Add(curRuleHtmlPart);

                    if (rule.TranslatedDestination != null && rule.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        curRuleHtmlPart = "      <td>" + BuildConversionIncidentLinkTag(rule.TranslatedDestination.ConvertedCommandId) + xdest + "</td>";
                        if (rule.TranslatedDestination.ConversionIncidentType > ruleConversionIncidentType)
                        {
                            ruleConversionIncidentType = rule.TranslatedDestination.ConversionIncidentType;
                        }
                    }
                    else
                    {
                        curRuleHtmlPart = "      <td>" + xdest + "</td>";
                    }
                    file.WriteLine(curRuleHtmlPart);
                    curRuleHtmlFull.Add(curRuleHtmlPart);

                    if (rule.TranslatedService != null && rule.TranslatedService.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        curRuleHtmlPart = "      <td>" + BuildConversionIncidentLinkTag(rule.TranslatedService.ConvertedCommandId) + xservice + "</td>";
                        if (rule.TranslatedService.ConversionIncidentType > ruleConversionIncidentType)
                        {
                            ruleConversionIncidentType = rule.TranslatedService.ConversionIncidentType;
                        }
                    }
                    else
                    {
                        curRuleHtmlPart = "      <td>" + xservice + "</td>";
                    }
                    file.WriteLine(curRuleHtmlPart);
                    curRuleHtmlFull.Add(curRuleHtmlPart);

                    curRuleHtmlPart = "      <td class='comments'>" + rule.Comments + "</td>";
                    file.WriteLine(curRuleHtmlPart);
                    curRuleHtmlFull.Add(curRuleHtmlPart);

                    file.WriteLine("  </tr>");
                    curRuleHtmlFull.Add("  </tr>");

                    if (_hasNATConversionIncident && ruleConversionIncidentType != ConversionIncidentType.None)
                    {
                        if (ruleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                        {
                            ++errorsCount;
                            rulesWithConversionErrors.AddRange(curRuleHtmlFull);
                        }
                        else
                        {
                            ++infosCount;
                            rulesWithConversionInfos.AddRange(curRuleHtmlFull);
                        }
                    }

                    ruleNumber++;
                }

                file.WriteLine("</table>");

                if (rulesWithConversionErrors.Count > 0 || rulesWithConversionInfos.Count > 0)
                {
                    file.WriteLine("<div id=\"PolicyConversionIncidents\" style='margin-left: 20px;'><h2>NAT Conversion Issues</h2></div>");
                }

                // Generate the errors report
                if (rulesWithConversionErrors.Count > 0)
                {
                    file.WriteLine("<script>");
                    file.WriteLine("   errorsCounter = " + errorsCount + ";");
                    file.WriteLine("</script>");

                    file.WriteLine("<div id=\"PolicyConversionErrors\" style='margin-left: 20px;'><h3>Conversion Errors</h3></div>");
                    file.WriteLine("<table style='background-color: rgb(255,255,150);'>");
                    file.WriteLine("   <tr>");
                    file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Translated-Source</th> <th class='errors_header'>Translated-Destination</th> <th class='errors_header'>Translated-Service</th> <th class='errors_header'>Comments</th>");
                    file.WriteLine("   </tr>");

                    foreach (var ruleHtml in rulesWithConversionErrors)
                    {
                        file.WriteLine(ruleHtml);
                    }

                    file.WriteLine("</table>");
                }

                // Generate the information report
                if (rulesWithConversionInfos.Count > 0)
                {
                    file.WriteLine("<script>");
                    file.WriteLine("   infosCounter = " + infosCount + ";");
                    file.WriteLine("</script>");

                    file.WriteLine("<div id=\"PolicyConversionInfos\" style='margin-left: 20px;'><h3>Conversion Notifications</h3></div>");
                    file.WriteLine("<table style='background-color: rgb(220,240,247);'>");
                    file.WriteLine("   <tr>");
                    file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Translated-Source</th> <th class='errors_header'>Translated-Destination</th> <th class='errors_header'>Translated-Service</th> <th class='errors_header'>Comments</th>");
                    file.WriteLine("   </tr>");

                    foreach (var ruleHtml in rulesWithConversionInfos)
                    {
                        file.WriteLine(ruleHtml);
                    }

                    file.WriteLine("</table>");
                }

                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        #endregion
    }
}
